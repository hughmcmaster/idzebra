/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 1.3.15u-20021003-1203
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

/***********************************************************************
 * common.swg
 *
 *     This file contains generic SWIG runtime support for pointer
 *     type checking as well as a few commonly used macros to control
 *     external linkage.
 *
 * Author : David Beazley (beazley@cs.uchicago.edu)
 *
 * Copyright (c) 1999-2000, The University of Chicago
 * 
 * This file may be freely redistributed without license or fee provided
 * this copyright message remains intact.
 ************************************************************************/

#include <string.h>

#if defined(_WIN32) || defined(__WIN32__)
#       if defined(_MSC_VER)
#               if defined(STATIC_LINKED)
#                       define SWIGEXPORT(a) a
#                       define SWIGIMPORT(a) extern a
#               else
#                       define SWIGEXPORT(a) __declspec(dllexport) a
#                       define SWIGIMPORT(a) extern a
#               endif
#       else
#               if defined(__BORLANDC__)
#                       define SWIGEXPORT(a) a _export
#                       define SWIGIMPORT(a) a _export
#               else
#                       define SWIGEXPORT(a) a
#                       define SWIGIMPORT(a) a
#               endif
#       endif
#else
#       define SWIGEXPORT(a) a
#       define SWIGIMPORT(a) a
#endif

#ifdef SWIG_GLOBAL
#define SWIGRUNTIME(a) SWIGEXPORT(a)
#else
#define SWIGRUNTIME(a) static a
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

typedef struct swig_type_info {
  const char             *name;                 
  swig_converter_func     converter;
  const char             *str;
  void                   *clientdata;	
  swig_dycast_func        dcast;
  struct swig_type_info  *next;
  struct swig_type_info  *prev;
} swig_type_info;

#ifdef SWIG_NOINCLUDE

SWIGIMPORT(swig_type_info *) SWIG_TypeRegister(swig_type_info *);
SWIGIMPORT(swig_type_info *) SWIG_TypeCheck(char *c, swig_type_info *);
SWIGIMPORT(void *)           SWIG_TypeCast(swig_type_info *, void *);
SWIGIMPORT(swig_type_info *) SWIG_TypeDynamicCast(swig_type_info *, void **);
SWIGIMPORT(swig_type_info *) SWIG_TypeQuery(const char *);
SWIGIMPORT(void)             SWIG_TypeClientData(swig_type_info *, void *);

#else

static swig_type_info *swig_type_list = 0;

/* Register a type mapping with the type-checking */
SWIGRUNTIME(swig_type_info *)
SWIG_TypeRegister(swig_type_info *ti)
{
  swig_type_info *tc, *head, *ret, *next;
  /* Check to see if this type has already been registered */
  tc = swig_type_list;
  while (tc) {
    if (strcmp(tc->name, ti->name) == 0) {
      /* Already exists in the table.  Just add additional types to the list */
      if (tc->clientdata) ti->clientdata = tc->clientdata;	
      head = tc;
      next = tc->next;
      goto l1;
    }
    tc = tc->prev;
  }
  head = ti;
  next = 0;

  /* Place in list */
  ti->prev = swig_type_list;
  swig_type_list = ti;

  /* Build linked lists */
 l1:
  ret = head;
  tc = ti + 1;
  /* Patch up the rest of the links */
  while (tc->name) {
    head->next = tc;
    tc->prev = head;
    head = tc;
    tc++;
  }
  head->next = next;
  return ret;
}

/* Check the typename */
SWIGRUNTIME(swig_type_info *) 
SWIG_TypeCheck(char *c, swig_type_info *ty)
{
  swig_type_info *s;
  if (!ty) return 0;        /* Void pointer */
  s = ty->next;             /* First element always just a name */
  do {
    if (strcmp(s->name,c) == 0) {
      if (s == ty->next) return s;
      /* Move s to the top of the linked list */
      s->prev->next = s->next;
      if (s->next) {
	s->next->prev = s->prev;
      }
      /* Insert s as second element in the list */
      s->next = ty->next;
      if (ty->next) ty->next->prev = s;
      ty->next = s;
      return s;
    }
    s = s->next;
  } while (s && (s != ty->next));
  return 0;
}

/* Cast a pointer up an inheritance hierarchy */
SWIGRUNTIME(void *) 
SWIG_TypeCast(swig_type_info *ty, void *ptr) 
{
  if ((!ty) || (!ty->converter)) return ptr;
  return (*ty->converter)(ptr);
}

/* Dynamic pointer casting. Down an inheritance hierarchy */
SWIGRUNTIME(swig_type_info *) 
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) 
{
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
     ty = (*ty->dcast)(ptr);
     if (ty) lastty = ty;
  }
  return lastty;
}

/* Search for a swig_type_info structure */
SWIGRUNTIME(swig_type_info *)
SWIG_TypeQuery(const char *name) {
  swig_type_info *ty = swig_type_list;
  while (ty) {
    if (ty->str && (strcmp(name,ty->str) == 0)) return ty;
    if (ty->name && (strcmp(name,ty->name) == 0)) return ty;
    ty = ty->prev;
  }
  return 0;
}

/* Set the clientdata field for a type */
SWIGRUNTIME(void)
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_type_info *tc, *equiv;
  if (ti->clientdata) return;
  ti->clientdata = clientdata;
  equiv = ti->next;
  while (equiv) {
    if (!equiv->converter) {
      tc = swig_type_list;
      while (tc) {
	if ((strcmp(tc->name, equiv->name) == 0))
	  SWIG_TypeClientData(tc,clientdata);
	tc = tc->prev;
      }
    }
    equiv = equiv->next;
  }
}
#endif

#ifdef __cplusplus
}

#endif

/* -----------------------------------------------------------------------------
 * perl5.swg
 *
 * Perl5 runtime library
 * $Header: /home/cvsroot/idis/perl/Attic/IDZebra_wrap.c,v 1.20 2003-07-26 16:27:46 pop Exp $
 * ----------------------------------------------------------------------------- */

#define SWIGPERL
#define SWIGPERL5
#ifdef __cplusplus
/* Needed on some windows machines---since MS plays funny
   games with the header files under C++ */
#include <math.h>
#include <stdlib.h>
extern "C" {
#endif
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

/* Get rid of free and malloc defined by perl */
#undef free
#undef malloc

#ifndef pTHX_
#define pTHX_
#endif

#include <string.h>
#ifdef __cplusplus
}
#endif

/* Macro to call an XS function */

#ifdef PERL_OBJECT 
#define SWIG_CALLXS(_name) _name(cv,pPerl) 
#else 
#ifndef MULTIPLICITY 
#define SWIG_CALLXS(_name) _name(cv) 
#else 
#define SWIG_CALLXS(_name) _name(PERL_GET_THX, cv) 
#endif 
#endif 

/* Macros for low-level exception handling */
#define SWIG_fail      goto fail
#define SWIG_croak(x)  while ((_swigerr = (const char *) x)) goto fail
#define SWIG_MAX_ERRMSG 256

/* Note: SwigMagicFuncHack is a typedef used to get the C++
   compiler to just shut up already */

#ifdef PERL_OBJECT
#define MAGIC_PPERL  CPerlObj *pPerl = (CPerlObj *) this;
typedef int (CPerlObj::*SwigMagicFunc)(SV *, MAGIC *);

#ifdef __cplusplus
extern "C" {
#endif
typedef int (CPerlObj::*SwigMagicFuncHack)(SV *, MAGIC *);
#ifdef __cplusplus
}
#endif

#define SWIG_MAGIC(a,b) (SV *a, MAGIC *b)
#define SWIGCLASS_STATIC
#else
#define MAGIC_PPERL
#define SWIGCLASS_STATIC static
#ifndef MULTIPLICITY
#define SWIG_MAGIC(a,b) (SV *a, MAGIC *b)
typedef int (*SwigMagicFunc)(SV *, MAGIC *);

#ifdef __cplusplus
extern "C" {
#endif
typedef int (*SwigMagicFuncHack)(SV *, MAGIC *);
#ifdef __cplusplus
}
#endif


#else
#define SWIG_MAGIC(a,b) (struct interpreter *interp, SV *a, MAGIC *b)
typedef int (*SwigMagicFunc)(struct interpreter *, SV *, MAGIC *);
#ifdef __cplusplus
extern "C" {
#endif
typedef int (*SwigMagicFuncHack)(struct interpreter *, SV *, MAGIC *);
#ifdef __cplusplus
}
#endif

#endif
#endif

#if defined(WIN32) && defined(PERL_OBJECT) && !defined(PerlIO_exportFILE)
#define PerlIO_exportFILE(fh,fl) (FILE*)(fh)
#endif

/* Modifications for newer Perl 5.005 releases */

#if !defined(PERL_REVISION) || ((PERL_REVISION >= 5) && ((PERL_VERSION < 5) || ((PERL_VERSION == 5) && (PERL_SUBVERSION < 50))))
#ifndef PL_sv_yes
#define PL_sv_yes sv_yes
#endif
#ifndef PL_sv_undef
#define PL_sv_undef sv_undef
#endif
#ifndef PL_na
#define PL_na na
#endif
#endif

#include <stdlib.h>

#ifdef __cplusplus
extern "C" {
#endif

#ifdef SWIG_NOINCLUDE

#ifndef PERL_OBJECT
extern int SWIG_ConvertPtr(SV *, void **, swig_type_info *, int flags);
extern void SWIG_MakePtr(SV *, void *, swig_type_info *, int flags);
#else
extern int _SWIG_ConvertPtr(CPerlObj *, SV *, void **, swig_type_info *,int flags);
extern void _SWIG_MakePtr(CPerlObj *, SV *, void *, swig_type_info *, int flags);
#define SWIG_ConvertPtr(a,b,c,d) _SWIG_ConvertPtr(pPerl,a,b,c,d)
#define SWIG_MakePtr(a,b,c,d) _SWIG_MakePtr(pPerl,a,b,c,d)
#endif

#else

/* Function for getting a pointer value */

#ifndef PERL_OBJECT
SWIGRUNTIME(int) 
SWIG_ConvertPtr(SV *sv, void **ptr, swig_type_info *_t, int flags)
#else
#define SWIG_ConvertPtr(a,b,c,d) _SWIG_ConvertPtr(pPerl,a,b,c,d)
SWIGRUNTIME(int)
_SWIG_ConvertPtr(CPerlObj *pPerl, SV *sv, void **ptr, swig_type_info *_t, int flags)
#endif
{
  char *_c;
  swig_type_info *tc;
  IV   tmp;

  /* If magical, apply more magic */
  if (SvGMAGICAL(sv))
    mg_get(sv);

  /* Check to see if this is an object */
  if (sv_isobject(sv)) {
    SV *tsv = (SV*) SvRV(sv);
    if ((SvTYPE(tsv) == SVt_PVHV)) {
      MAGIC *mg;
      if (SvMAGICAL(tsv)) {
	mg = mg_find(tsv,'P');
	if (mg) {
	  SV *rsv = mg->mg_obj;
	  if (sv_isobject(rsv)) {
	    tmp = SvIV((SV*)SvRV(rsv));
	  }
	}
      } else {
	return -1;
      }
    } else {
      tmp = SvIV((SV*)SvRV(sv));
    }
    if (!_t) {
      *(ptr) = (void *) tmp;
      return 0;
    }
  } else if (! SvOK(sv)) {            /* Check for undef */
    *(ptr) = (void *) 0;
    return 0;
  } else if (SvTYPE(sv) == SVt_RV) {  /* Check for NULL pointer */
    *(ptr) = (void *) 0;
    if (!SvROK(sv)) 
      return 0;
    else
      return -1;
  } else {                            /* Don't know what it is */
      *(ptr) = (void *) 0;
      return -1;
  }
  if (_t) {
    /* Now see if the types match */      
    _c = HvNAME(SvSTASH(SvRV(sv)));
    tc = SWIG_TypeCheck(_c,_t);
    if (!tc) {
      *ptr = (void *) tmp;
      return -1;
    }
    *ptr = SWIG_TypeCast(tc,(void *)tmp);
    return 0;
  }
  *ptr = (void *) tmp;
  return 0;
}
#ifndef PERL_OBJECT
SWIGRUNTIME(void) 
SWIG_MakePtr(SV *sv, void *ptr, swig_type_info *t,int flags)
#else
#define SWIG_MakePtr(a,b,c,d) _SWIG_MakePtr(pPerl,a,b,c,d)
SWIGRUNTIME(void)
_SWIG_MakePtr(CPerlObj *pPerl, SV *sv, void *ptr, swig_type_info *t, int flags)
#endif
{
  sv_setref_pv(sv, (char *) t->name, ptr);
}

#endif

typedef XS(SwigPerlWrapper);
typedef SwigPerlWrapper *SwigPerlWrapperPtr;

/* Structure for command table */
typedef struct {
  const char         *name;
  SwigPerlWrapperPtr  wrapper;
} swig_command_info;

/* Information for constant table */

#define SWIG_INT     1
#define SWIG_FLOAT   2
#define SWIG_STRING  3
#define SWIG_POINTER 4
#define SWIG_BINARY  5

/* Constant information structure */
typedef struct swig_constant_info {
    int              type;
    const char      *name;
    long             lvalue;
    double           dvalue;
    void            *pvalue;
    swig_type_info **ptype;
} swig_constant_info;

#ifdef __cplusplus
}
#endif

/* Structure for variable table */
typedef struct {
  const char   *name;
  SwigMagicFunc   set;
  SwigMagicFunc   get;
  swig_type_info  **type;
} swig_variable_info;

/* Magic variable code */
#ifndef PERL_OBJECT
#define swig_create_magic(s,a,b,c) _swig_create_magic(s,a,b,c)
  #ifndef MULTIPLICITY 
       static void _swig_create_magic(SV *sv, char *name, int (*set)(SV *, MAGIC *), int \
(*get)(SV *,MAGIC *)) { 
  #else 
       static void _swig_create_magic(SV *sv, char *name, int (*set)(struct interpreter*,\
 SV *, MAGIC *), int (*get)(struct interpreter*, SV *,MAGIC *)) { 
  #endif 
#else
#define swig_create_magic(s,a,b,c) _swig_create_magic(pPerl,s,a,b,c)
static void _swig_create_magic(CPerlObj *pPerl, SV *sv, const char *name, int (CPerlObj::*set)(SV *, MAGIC *), int (CPerlObj::*get)(SV *, MAGIC *)) {
#endif
  MAGIC *mg;
  sv_magic(sv,sv,'U',(char *) name,strlen(name));
  mg = mg_find(sv,'U');
  mg->mg_virtual = (MGVTBL *) malloc(sizeof(MGVTBL));
  mg->mg_virtual->svt_get = (SwigMagicFuncHack) get;
  mg->mg_virtual->svt_set = (SwigMagicFuncHack) set;
  mg->mg_virtual->svt_len = 0;
  mg->mg_virtual->svt_clear = 0;
  mg->mg_virtual->svt_free = 0;
}







/* -------- TYPES TABLE (BEGIN) -------- */

#define  SWIGTYPE_p_ZebraService swig_types[0] 
#define  SWIGTYPE_p_cql_transform_t swig_types[1] 
#define  SWIGTYPE_p_data1_esetname swig_types[2] 
#define  SWIGTYPE_p_data1_maptab swig_types[3] 
#define  SWIGTYPE_p_ODR swig_types[4] 
#define  SWIGTYPE_p_f_p_void__int swig_types[5] 
#define  SWIGTYPE_p_p_char swig_types[6] 
#define  SWIGTYPE_p_data1_absyn swig_types[7] 
#define  SWIGTYPE_p_ZebraHandle swig_types[8] 
#define  SWIGTYPE_p_void swig_types[9] 
#define  SWIGTYPE_p_data1_attset swig_types[10] 
#define  SWIGTYPE_p_size_t swig_types[11] 
#define  SWIGTYPE_p_WRBUF swig_types[12] 
#define  SWIGTYPE_p_f_data1_handle_p_void_p_data1_absyn__void swig_types[13] 
#define  SWIGTYPE_p_Z_Espec1 swig_types[14] 
#define  SWIGTYPE_p_off_t swig_types[15] 
#define  SWIGTYPE_p_Odr_oid swig_types[16] 
#define  SWIGTYPE_p_data1_varset swig_types[17] 
#define  SWIGTYPE_p_RetrievalRecordBuf swig_types[18] 
#define  SWIGTYPE_p_perl_context swig_types[19] 
#define  SWIGTYPE_p_data1_node swig_types[20] 
#define  SWIGTYPE_p_ScanObj swig_types[21] 
#define  SWIGTYPE_p_RetrievalObj swig_types[22] 
#define  SWIGTYPE_p_data1_tagset swig_types[23] 
#define  SWIGTYPE_p_data1_tag swig_types[24] 
#define  SWIGTYPE_p_ZebraRetrievalRecord swig_types[25] 
#define  SWIGTYPE_p_RetrievalRecord swig_types[26] 
#define  SWIGTYPE_p_NMEM swig_types[27] 
#define  SWIGTYPE_p_Z_ExplainRecord swig_types[28] 
#define  SWIGTYPE_p_data1_marctab swig_types[29] 
#define  SWIGTYPE_p_ZebraTransactionStatus swig_types[30] 
#define  SWIGTYPE_p_Z_BriefBib swig_types[31] 
#define  SWIGTYPE_p_scanEntry swig_types[32] 
#define  SWIGTYPE_p_f_p_void_p_char_size_t__int swig_types[33] 
#define  SWIGTYPE_p_FILE swig_types[34] 
#define  SWIGTYPE_p_data1_element swig_types[35] 
#define  SWIGTYPE_p_recordGroup swig_types[36] 
#define  SWIGTYPE_p_int swig_types[37] 
#define  SWIGTYPE_p_data1_handle swig_types[38] 
#define  SWIGTYPE_p_p_int swig_types[39] 
#define  SWIGTYPE_p_data1_absyn_cache swig_types[40] 
#define  SWIGTYPE_p_data1_attset_cache swig_types[41] 
#define  SWIGTYPE_p_Z_GenericRecord swig_types[42] 
#define  SWIGTYPE_p_data1_vartype swig_types[43] 
static swig_type_info *swig_types[45];

/* -------- TYPES TABLE (END) -------- */

#define SWIG_init    boot_IDZebra

#define SWIG_name   "IDZebrac::boot_IDZebra"
#define SWIG_prefix "IDZebrac::"

#ifdef __cplusplus
extern "C"
#endif
#ifndef PERL_OBJECT
#ifndef MULTIPLICITY
SWIGEXPORT(void) SWIG_init (CV* cv);
#else
SWIGEXPORT(void) SWIG_init (pTHXo_ CV* cv);
#endif
#else
SWIGEXPORT(void) SWIG_init (CV *cv, CPerlObj *);
#endif


#include "zebraapi.h"
#include "zebra_perl.h"
#include "data1.h"
#include "yaz/odr.h"
#include "yaz/cql.h"

#ifdef PERL_OBJECT
#define MAGIC_CLASS _wrap_IDZebra_var::
class _wrap_IDZebra_var : public CPerlObj {
public:
#else
#define MAGIC_CLASS
#endif
SWIGCLASS_STATIC int swig_magic_readonly(pTHX_ SV *sv, MAGIC *mg) {
    MAGIC_PPERL
    sv = sv; mg = mg;
    croak("Value is read-only.");
    return 0;
}


#ifdef PERL_OBJECT
};
#endif

#ifdef __cplusplus
extern "C" {
#endif
XS(_wrap_recordGroup_groupName_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        recordGroup *arg1 ;
        char *arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: recordGroup_groupName_set(self,groupName);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_recordGroup,0) < 0) {
                SWIG_croak("Type error in argument 1 of recordGroup_groupName_set. Expected _p_recordGroup");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        {
            if (arg1->groupName) free((char*)arg1->groupName);
            arg1->groupName = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->groupName,arg2);
        }
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_recordGroup_groupName_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        recordGroup *arg1 ;
        char *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: recordGroup_groupName_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_recordGroup,0) < 0) {
                SWIG_croak("Type error in argument 1 of recordGroup_groupName_get. Expected _p_recordGroup");
            }
        }
        result = (char *) ((arg1)->groupName);
        
        ST(argvi) = sv_newmortal();
        if (result) {
            sv_setpv((SV*)ST(argvi++), (char *) result);
        }else {
            sv_setsv((SV*)ST(argvi++), &PL_sv_undef);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_recordGroup_databaseName_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        recordGroup *arg1 ;
        char *arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: recordGroup_databaseName_set(self,databaseName);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_recordGroup,0) < 0) {
                SWIG_croak("Type error in argument 1 of recordGroup_databaseName_set. Expected _p_recordGroup");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        {
            if (arg1->databaseName) free((char*)arg1->databaseName);
            arg1->databaseName = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->databaseName,arg2);
        }
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_recordGroup_databaseName_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        recordGroup *arg1 ;
        char *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: recordGroup_databaseName_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_recordGroup,0) < 0) {
                SWIG_croak("Type error in argument 1 of recordGroup_databaseName_get. Expected _p_recordGroup");
            }
        }
        result = (char *) ((arg1)->databaseName);
        
        ST(argvi) = sv_newmortal();
        if (result) {
            sv_setpv((SV*)ST(argvi++), (char *) result);
        }else {
            sv_setsv((SV*)ST(argvi++), &PL_sv_undef);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_recordGroup_path_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        recordGroup *arg1 ;
        char *arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: recordGroup_path_set(self,path);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_recordGroup,0) < 0) {
                SWIG_croak("Type error in argument 1 of recordGroup_path_set. Expected _p_recordGroup");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        {
            if (arg1->path) free((char*)arg1->path);
            arg1->path = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->path,arg2);
        }
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_recordGroup_path_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        recordGroup *arg1 ;
        char *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: recordGroup_path_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_recordGroup,0) < 0) {
                SWIG_croak("Type error in argument 1 of recordGroup_path_get. Expected _p_recordGroup");
            }
        }
        result = (char *) ((arg1)->path);
        
        ST(argvi) = sv_newmortal();
        if (result) {
            sv_setpv((SV*)ST(argvi++), (char *) result);
        }else {
            sv_setsv((SV*)ST(argvi++), &PL_sv_undef);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_recordGroup_recordId_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        recordGroup *arg1 ;
        char *arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: recordGroup_recordId_set(self,recordId);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_recordGroup,0) < 0) {
                SWIG_croak("Type error in argument 1 of recordGroup_recordId_set. Expected _p_recordGroup");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        {
            if (arg1->recordId) free((char*)arg1->recordId);
            arg1->recordId = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->recordId,arg2);
        }
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_recordGroup_recordId_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        recordGroup *arg1 ;
        char *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: recordGroup_recordId_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_recordGroup,0) < 0) {
                SWIG_croak("Type error in argument 1 of recordGroup_recordId_get. Expected _p_recordGroup");
            }
        }
        result = (char *) ((arg1)->recordId);
        
        ST(argvi) = sv_newmortal();
        if (result) {
            sv_setpv((SV*)ST(argvi++), (char *) result);
        }else {
            sv_setsv((SV*)ST(argvi++), &PL_sv_undef);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_recordGroup_recordType_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        recordGroup *arg1 ;
        char *arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: recordGroup_recordType_set(self,recordType);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_recordGroup,0) < 0) {
                SWIG_croak("Type error in argument 1 of recordGroup_recordType_set. Expected _p_recordGroup");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        {
            if (arg1->recordType) free((char*)arg1->recordType);
            arg1->recordType = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->recordType,arg2);
        }
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_recordGroup_recordType_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        recordGroup *arg1 ;
        char *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: recordGroup_recordType_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_recordGroup,0) < 0) {
                SWIG_croak("Type error in argument 1 of recordGroup_recordType_get. Expected _p_recordGroup");
            }
        }
        result = (char *) ((arg1)->recordType);
        
        ST(argvi) = sv_newmortal();
        if (result) {
            sv_setpv((SV*)ST(argvi++), (char *) result);
        }else {
            sv_setsv((SV*)ST(argvi++), &PL_sv_undef);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_recordGroup_flagStoreData_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        recordGroup *arg1 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: recordGroup_flagStoreData_set(self,flagStoreData);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_recordGroup,0) < 0) {
                SWIG_croak("Type error in argument 1 of recordGroup_flagStoreData_set. Expected _p_recordGroup");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->flagStoreData = arg2;
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_recordGroup_flagStoreData_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        recordGroup *arg1 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: recordGroup_flagStoreData_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_recordGroup,0) < 0) {
                SWIG_croak("Type error in argument 1 of recordGroup_flagStoreData_get. Expected _p_recordGroup");
            }
        }
        result = (int) ((arg1)->flagStoreData);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_recordGroup_flagStoreKeys_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        recordGroup *arg1 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: recordGroup_flagStoreKeys_set(self,flagStoreKeys);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_recordGroup,0) < 0) {
                SWIG_croak("Type error in argument 1 of recordGroup_flagStoreKeys_set. Expected _p_recordGroup");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->flagStoreKeys = arg2;
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_recordGroup_flagStoreKeys_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        recordGroup *arg1 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: recordGroup_flagStoreKeys_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_recordGroup,0) < 0) {
                SWIG_croak("Type error in argument 1 of recordGroup_flagStoreKeys_get. Expected _p_recordGroup");
            }
        }
        result = (int) ((arg1)->flagStoreKeys);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_recordGroup_flagRw_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        recordGroup *arg1 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: recordGroup_flagRw_set(self,flagRw);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_recordGroup,0) < 0) {
                SWIG_croak("Type error in argument 1 of recordGroup_flagRw_set. Expected _p_recordGroup");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->flagRw = arg2;
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_recordGroup_flagRw_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        recordGroup *arg1 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: recordGroup_flagRw_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_recordGroup,0) < 0) {
                SWIG_croak("Type error in argument 1 of recordGroup_flagRw_get. Expected _p_recordGroup");
            }
        }
        result = (int) ((arg1)->flagRw);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_recordGroup_fileVerboseLimit_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        recordGroup *arg1 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: recordGroup_fileVerboseLimit_set(self,fileVerboseLimit);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_recordGroup,0) < 0) {
                SWIG_croak("Type error in argument 1 of recordGroup_fileVerboseLimit_set. Expected _p_recordGroup");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->fileVerboseLimit = arg2;
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_recordGroup_fileVerboseLimit_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        recordGroup *arg1 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: recordGroup_fileVerboseLimit_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_recordGroup,0) < 0) {
                SWIG_croak("Type error in argument 1 of recordGroup_fileVerboseLimit_get. Expected _p_recordGroup");
            }
        }
        result = (int) ((arg1)->fileVerboseLimit);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_recordGroup_databaseNamePath_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        recordGroup *arg1 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: recordGroup_databaseNamePath_set(self,databaseNamePath);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_recordGroup,0) < 0) {
                SWIG_croak("Type error in argument 1 of recordGroup_databaseNamePath_set. Expected _p_recordGroup");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->databaseNamePath = arg2;
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_recordGroup_databaseNamePath_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        recordGroup *arg1 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: recordGroup_databaseNamePath_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_recordGroup,0) < 0) {
                SWIG_croak("Type error in argument 1 of recordGroup_databaseNamePath_get. Expected _p_recordGroup");
            }
        }
        result = (int) ((arg1)->databaseNamePath);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_recordGroup_explainDatabase_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        recordGroup *arg1 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: recordGroup_explainDatabase_set(self,explainDatabase);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_recordGroup,0) < 0) {
                SWIG_croak("Type error in argument 1 of recordGroup_explainDatabase_set. Expected _p_recordGroup");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->explainDatabase = arg2;
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_recordGroup_explainDatabase_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        recordGroup *arg1 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: recordGroup_explainDatabase_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_recordGroup,0) < 0) {
                SWIG_croak("Type error in argument 1 of recordGroup_explainDatabase_get. Expected _p_recordGroup");
            }
        }
        result = (int) ((arg1)->explainDatabase);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_recordGroup_followLinks_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        recordGroup *arg1 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: recordGroup_followLinks_set(self,followLinks);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_recordGroup,0) < 0) {
                SWIG_croak("Type error in argument 1 of recordGroup_followLinks_set. Expected _p_recordGroup");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->followLinks = arg2;
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_recordGroup_followLinks_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        recordGroup *arg1 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: recordGroup_followLinks_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_recordGroup,0) < 0) {
                SWIG_croak("Type error in argument 1 of recordGroup_followLinks_get. Expected _p_recordGroup");
            }
        }
        result = (int) ((arg1)->followLinks);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_new_recordGroup) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        recordGroup *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 0) || (items > 0)) {
            SWIG_croak("Usage: new_recordGroup();");
        }
        result = (recordGroup *)(recordGroup *) calloc(1, sizeof(recordGroup));
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_recordGroup,0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_delete_recordGroup) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        recordGroup *arg1 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: delete_recordGroup(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_recordGroup,0) < 0) {
                SWIG_croak("Type error in argument 1 of delete_recordGroup. Expected _p_recordGroup");
            }
        }
        free((char *) arg1);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_RetrievalObj_noOfRecords_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        RetrievalObj *arg1 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: RetrievalObj_noOfRecords_set(self,noOfRecords);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_RetrievalObj,0) < 0) {
                SWIG_croak("Type error in argument 1 of RetrievalObj_noOfRecords_set. Expected _p_RetrievalObj");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->noOfRecords = arg2;
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_RetrievalObj_noOfRecords_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        RetrievalObj *arg1 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: RetrievalObj_noOfRecords_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_RetrievalObj,0) < 0) {
                SWIG_croak("Type error in argument 1 of RetrievalObj_noOfRecords_get. Expected _p_RetrievalObj");
            }
        }
        result = (int) ((arg1)->noOfRecords);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_RetrievalObj_records_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        RetrievalObj *arg1 ;
        ZebraRetrievalRecord *arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: RetrievalObj_records_set(self,records);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_RetrievalObj,0) < 0) {
                SWIG_croak("Type error in argument 1 of RetrievalObj_records_set. Expected _p_RetrievalObj");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_ZebraRetrievalRecord,0) < 0) {
                SWIG_croak("Type error in argument 2 of RetrievalObj_records_set. Expected _p_ZebraRetrievalRecord");
            }
        }
        if (arg1) (arg1)->records = arg2;
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_RetrievalObj_records_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        RetrievalObj *arg1 ;
        ZebraRetrievalRecord *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: RetrievalObj_records_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_RetrievalObj,0) < 0) {
                SWIG_croak("Type error in argument 1 of RetrievalObj_records_get. Expected _p_RetrievalObj");
            }
        }
        result = (ZebraRetrievalRecord *) ((arg1)->records);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_ZebraRetrievalRecord,0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_new_RetrievalObj) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        RetrievalObj *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 0) || (items > 0)) {
            SWIG_croak("Usage: new_RetrievalObj();");
        }
        result = (RetrievalObj *)(RetrievalObj *) calloc(1, sizeof(RetrievalObj));
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_RetrievalObj,0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_delete_RetrievalObj) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        RetrievalObj *arg1 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: delete_RetrievalObj(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_RetrievalObj,0) < 0) {
                SWIG_croak("Type error in argument 1 of delete_RetrievalObj. Expected _p_RetrievalObj");
            }
        }
        free((char *) arg1);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_RetrievalRecord_errCode_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        RetrievalRecord *arg1 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: RetrievalRecord_errCode_set(self,errCode);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_RetrievalRecord,0) < 0) {
                SWIG_croak("Type error in argument 1 of RetrievalRecord_errCode_set. Expected _p_RetrievalRecord");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->errCode = arg2;
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_RetrievalRecord_errCode_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        RetrievalRecord *arg1 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: RetrievalRecord_errCode_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_RetrievalRecord,0) < 0) {
                SWIG_croak("Type error in argument 1 of RetrievalRecord_errCode_get. Expected _p_RetrievalRecord");
            }
        }
        result = (int) ((arg1)->errCode);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_RetrievalRecord_errString_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        RetrievalRecord *arg1 ;
        char *arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: RetrievalRecord_errString_set(self,errString);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_RetrievalRecord,0) < 0) {
                SWIG_croak("Type error in argument 1 of RetrievalRecord_errString_set. Expected _p_RetrievalRecord");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        {
            if (arg1->errString) free((char*)arg1->errString);
            arg1->errString = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->errString,arg2);
        }
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_RetrievalRecord_errString_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        RetrievalRecord *arg1 ;
        char *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: RetrievalRecord_errString_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_RetrievalRecord,0) < 0) {
                SWIG_croak("Type error in argument 1 of RetrievalRecord_errString_get. Expected _p_RetrievalRecord");
            }
        }
        result = (char *) ((arg1)->errString);
        
        ST(argvi) = sv_newmortal();
        if (result) {
            sv_setpv((SV*)ST(argvi++), (char *) result);
        }else {
            sv_setsv((SV*)ST(argvi++), &PL_sv_undef);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_RetrievalRecord_position_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        RetrievalRecord *arg1 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: RetrievalRecord_position_set(self,position);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_RetrievalRecord,0) < 0) {
                SWIG_croak("Type error in argument 1 of RetrievalRecord_position_set. Expected _p_RetrievalRecord");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->position = arg2;
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_RetrievalRecord_position_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        RetrievalRecord *arg1 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: RetrievalRecord_position_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_RetrievalRecord,0) < 0) {
                SWIG_croak("Type error in argument 1 of RetrievalRecord_position_get. Expected _p_RetrievalRecord");
            }
        }
        result = (int) ((arg1)->position);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_RetrievalRecord_base_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        RetrievalRecord *arg1 ;
        char *arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: RetrievalRecord_base_set(self,base);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_RetrievalRecord,0) < 0) {
                SWIG_croak("Type error in argument 1 of RetrievalRecord_base_set. Expected _p_RetrievalRecord");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        {
            if (arg1->base) free((char*)arg1->base);
            arg1->base = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->base,arg2);
        }
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_RetrievalRecord_base_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        RetrievalRecord *arg1 ;
        char *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: RetrievalRecord_base_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_RetrievalRecord,0) < 0) {
                SWIG_croak("Type error in argument 1 of RetrievalRecord_base_get. Expected _p_RetrievalRecord");
            }
        }
        result = (char *) ((arg1)->base);
        
        ST(argvi) = sv_newmortal();
        if (result) {
            sv_setpv((SV*)ST(argvi++), (char *) result);
        }else {
            sv_setsv((SV*)ST(argvi++), &PL_sv_undef);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_RetrievalRecord_sysno_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        RetrievalRecord *arg1 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: RetrievalRecord_sysno_set(self,sysno);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_RetrievalRecord,0) < 0) {
                SWIG_croak("Type error in argument 1 of RetrievalRecord_sysno_set. Expected _p_RetrievalRecord");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->sysno = arg2;
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_RetrievalRecord_sysno_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        RetrievalRecord *arg1 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: RetrievalRecord_sysno_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_RetrievalRecord,0) < 0) {
                SWIG_croak("Type error in argument 1 of RetrievalRecord_sysno_get. Expected _p_RetrievalRecord");
            }
        }
        result = (int) ((arg1)->sysno);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_RetrievalRecord_score_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        RetrievalRecord *arg1 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: RetrievalRecord_score_set(self,score);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_RetrievalRecord,0) < 0) {
                SWIG_croak("Type error in argument 1 of RetrievalRecord_score_set. Expected _p_RetrievalRecord");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->score = arg2;
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_RetrievalRecord_score_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        RetrievalRecord *arg1 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: RetrievalRecord_score_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_RetrievalRecord,0) < 0) {
                SWIG_croak("Type error in argument 1 of RetrievalRecord_score_get. Expected _p_RetrievalRecord");
            }
        }
        result = (int) ((arg1)->score);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_RetrievalRecord_format_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        RetrievalRecord *arg1 ;
        char *arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: RetrievalRecord_format_set(self,format);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_RetrievalRecord,0) < 0) {
                SWIG_croak("Type error in argument 1 of RetrievalRecord_format_set. Expected _p_RetrievalRecord");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        {
            if (arg1->format) free((char*)arg1->format);
            arg1->format = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->format,arg2);
        }
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_RetrievalRecord_format_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        RetrievalRecord *arg1 ;
        char *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: RetrievalRecord_format_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_RetrievalRecord,0) < 0) {
                SWIG_croak("Type error in argument 1 of RetrievalRecord_format_get. Expected _p_RetrievalRecord");
            }
        }
        result = (char *) ((arg1)->format);
        
        ST(argvi) = sv_newmortal();
        if (result) {
            sv_setpv((SV*)ST(argvi++), (char *) result);
        }else {
            sv_setsv((SV*)ST(argvi++), &PL_sv_undef);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_RetrievalRecord_buf_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        RetrievalRecord *arg1 ;
        RetrievalRecordBuf *arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: RetrievalRecord_buf_set(self,buf);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_RetrievalRecord,0) < 0) {
                SWIG_croak("Type error in argument 1 of RetrievalRecord_buf_set. Expected _p_RetrievalRecord");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_RetrievalRecordBuf,0) < 0) {
                SWIG_croak("Type error in argument 2 of RetrievalRecord_buf_set. Expected _p_RetrievalRecordBuf");
            }
        }
        if (arg1) (arg1)->buf = arg2;
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_RetrievalRecord_buf_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        RetrievalRecord *arg1 ;
        RetrievalRecordBuf *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: RetrievalRecord_buf_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_RetrievalRecord,0) < 0) {
                SWIG_croak("Type error in argument 1 of RetrievalRecord_buf_get. Expected _p_RetrievalRecord");
            }
        }
        result = (RetrievalRecordBuf *) ((arg1)->buf);
        
        {
            if (result->len) {
                ST(argvi) = newSVpv(result->buf,result->len);
            }else {
                ST(argvi) = newSVpv("",0);
            }
            sv_2mortal(ST(argvi));
            argvi++;
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_new_RetrievalRecord) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        RetrievalRecord *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 0) || (items > 0)) {
            SWIG_croak("Usage: new_RetrievalRecord();");
        }
        result = (RetrievalRecord *)(RetrievalRecord *) calloc(1, sizeof(RetrievalRecord));
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_RetrievalRecord,0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_delete_RetrievalRecord) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        RetrievalRecord *arg1 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: delete_RetrievalRecord(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_RetrievalRecord,0) < 0) {
                SWIG_croak("Type error in argument 1 of delete_RetrievalRecord. Expected _p_RetrievalRecord");
            }
        }
        free((char *) arg1);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_scanEntry_occurrences_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        scanEntry *arg1 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: scanEntry_occurrences_set(self,occurrences);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_scanEntry,0) < 0) {
                SWIG_croak("Type error in argument 1 of scanEntry_occurrences_set. Expected _p_scanEntry");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->occurrences = arg2;
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_scanEntry_occurrences_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        scanEntry *arg1 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: scanEntry_occurrences_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_scanEntry,0) < 0) {
                SWIG_croak("Type error in argument 1 of scanEntry_occurrences_get. Expected _p_scanEntry");
            }
        }
        result = (int) ((arg1)->occurrences);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_scanEntry_term_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        scanEntry *arg1 ;
        char *arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: scanEntry_term_set(self,term);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_scanEntry,0) < 0) {
                SWIG_croak("Type error in argument 1 of scanEntry_term_set. Expected _p_scanEntry");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        {
            if (arg1->term) free((char*)arg1->term);
            arg1->term = (char *) malloc(strlen(arg2)+1);
            strcpy((char*)arg1->term,arg2);
        }
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_scanEntry_term_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        scanEntry *arg1 ;
        char *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: scanEntry_term_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_scanEntry,0) < 0) {
                SWIG_croak("Type error in argument 1 of scanEntry_term_get. Expected _p_scanEntry");
            }
        }
        result = (char *) ((arg1)->term);
        
        ST(argvi) = sv_newmortal();
        if (result) {
            sv_setpv((SV*)ST(argvi++), (char *) result);
        }else {
            sv_setsv((SV*)ST(argvi++), &PL_sv_undef);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_new_scanEntry) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        scanEntry *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 0) || (items > 0)) {
            SWIG_croak("Usage: new_scanEntry();");
        }
        result = (scanEntry *)(scanEntry *) calloc(1, sizeof(scanEntry));
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_scanEntry,0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_delete_scanEntry) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        scanEntry *arg1 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: delete_scanEntry(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_scanEntry,0) < 0) {
                SWIG_croak("Type error in argument 1 of delete_scanEntry. Expected _p_scanEntry");
            }
        }
        free((char *) arg1);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ScanObj_num_entries_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        ScanObj *arg1 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: ScanObj_num_entries_set(self,num_entries);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ScanObj,0) < 0) {
                SWIG_croak("Type error in argument 1 of ScanObj_num_entries_set. Expected _p_ScanObj");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->num_entries = arg2;
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ScanObj_num_entries_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        ScanObj *arg1 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: ScanObj_num_entries_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ScanObj,0) < 0) {
                SWIG_croak("Type error in argument 1 of ScanObj_num_entries_get. Expected _p_ScanObj");
            }
        }
        result = (int) ((arg1)->num_entries);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ScanObj_position_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        ScanObj *arg1 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: ScanObj_position_set(self,position);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ScanObj,0) < 0) {
                SWIG_croak("Type error in argument 1 of ScanObj_position_set. Expected _p_ScanObj");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->position = arg2;
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ScanObj_position_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        ScanObj *arg1 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: ScanObj_position_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ScanObj,0) < 0) {
                SWIG_croak("Type error in argument 1 of ScanObj_position_get. Expected _p_ScanObj");
            }
        }
        result = (int) ((arg1)->position);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ScanObj_is_partial_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        ScanObj *arg1 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: ScanObj_is_partial_set(self,is_partial);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ScanObj,0) < 0) {
                SWIG_croak("Type error in argument 1 of ScanObj_is_partial_set. Expected _p_ScanObj");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->is_partial = arg2;
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ScanObj_is_partial_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        ScanObj *arg1 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: ScanObj_is_partial_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ScanObj,0) < 0) {
                SWIG_croak("Type error in argument 1 of ScanObj_is_partial_get. Expected _p_ScanObj");
            }
        }
        result = (int) ((arg1)->is_partial);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ScanObj_entries_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        ScanObj *arg1 ;
        scanEntry *arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: ScanObj_entries_set(self,entries);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ScanObj,0) < 0) {
                SWIG_croak("Type error in argument 1 of ScanObj_entries_set. Expected _p_ScanObj");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_scanEntry,0) < 0) {
                SWIG_croak("Type error in argument 2 of ScanObj_entries_set. Expected _p_scanEntry");
            }
        }
        if (arg1) (arg1)->entries = arg2;
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ScanObj_entries_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        ScanObj *arg1 ;
        scanEntry *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: ScanObj_entries_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ScanObj,0) < 0) {
                SWIG_croak("Type error in argument 1 of ScanObj_entries_get. Expected _p_ScanObj");
            }
        }
        result = (scanEntry *) ((arg1)->entries);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_scanEntry,0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_new_ScanObj) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        ScanObj *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 0) || (items > 0)) {
            SWIG_croak("Usage: new_ScanObj();");
        }
        result = (ScanObj *)(ScanObj *) calloc(1, sizeof(ScanObj));
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_ScanObj,0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_delete_ScanObj) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        ScanObj *arg1 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: delete_ScanObj(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ScanObj,0) < 0) {
                SWIG_croak("Type error in argument 1 of delete_ScanObj. Expected _p_ScanObj");
            }
        }
        free((char *) arg1);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ZebraTransactionStatus_processed_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        ZebraTransactionStatus *arg1 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: ZebraTransactionStatus_processed_set(self,processed);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ZebraTransactionStatus,0) < 0) {
                SWIG_croak("Type error in argument 1 of ZebraTransactionStatus_processed_set. Expected _p_ZebraTransactionStatus");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->processed = arg2;
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ZebraTransactionStatus_processed_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        ZebraTransactionStatus *arg1 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: ZebraTransactionStatus_processed_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ZebraTransactionStatus,0) < 0) {
                SWIG_croak("Type error in argument 1 of ZebraTransactionStatus_processed_get. Expected _p_ZebraTransactionStatus");
            }
        }
        result = (int) ((arg1)->processed);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ZebraTransactionStatus_inserted_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        ZebraTransactionStatus *arg1 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: ZebraTransactionStatus_inserted_set(self,inserted);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ZebraTransactionStatus,0) < 0) {
                SWIG_croak("Type error in argument 1 of ZebraTransactionStatus_inserted_set. Expected _p_ZebraTransactionStatus");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->inserted = arg2;
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ZebraTransactionStatus_inserted_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        ZebraTransactionStatus *arg1 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: ZebraTransactionStatus_inserted_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ZebraTransactionStatus,0) < 0) {
                SWIG_croak("Type error in argument 1 of ZebraTransactionStatus_inserted_get. Expected _p_ZebraTransactionStatus");
            }
        }
        result = (int) ((arg1)->inserted);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ZebraTransactionStatus_updated_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        ZebraTransactionStatus *arg1 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: ZebraTransactionStatus_updated_set(self,updated);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ZebraTransactionStatus,0) < 0) {
                SWIG_croak("Type error in argument 1 of ZebraTransactionStatus_updated_set. Expected _p_ZebraTransactionStatus");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->updated = arg2;
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ZebraTransactionStatus_updated_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        ZebraTransactionStatus *arg1 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: ZebraTransactionStatus_updated_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ZebraTransactionStatus,0) < 0) {
                SWIG_croak("Type error in argument 1 of ZebraTransactionStatus_updated_get. Expected _p_ZebraTransactionStatus");
            }
        }
        result = (int) ((arg1)->updated);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ZebraTransactionStatus_deleted_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        ZebraTransactionStatus *arg1 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: ZebraTransactionStatus_deleted_set(self,deleted);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ZebraTransactionStatus,0) < 0) {
                SWIG_croak("Type error in argument 1 of ZebraTransactionStatus_deleted_set. Expected _p_ZebraTransactionStatus");
            }
        }
        arg2 = (int) SvIV(ST(1));
        if (arg1) (arg1)->deleted = arg2;
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ZebraTransactionStatus_deleted_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        ZebraTransactionStatus *arg1 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: ZebraTransactionStatus_deleted_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ZebraTransactionStatus,0) < 0) {
                SWIG_croak("Type error in argument 1 of ZebraTransactionStatus_deleted_get. Expected _p_ZebraTransactionStatus");
            }
        }
        result = (int) ((arg1)->deleted);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ZebraTransactionStatus_utime_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        ZebraTransactionStatus *arg1 ;
        long arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: ZebraTransactionStatus_utime_set(self,utime);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ZebraTransactionStatus,0) < 0) {
                SWIG_croak("Type error in argument 1 of ZebraTransactionStatus_utime_set. Expected _p_ZebraTransactionStatus");
            }
        }
        arg2 = (long) SvIV(ST(1));
        if (arg1) (arg1)->utime = arg2;
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ZebraTransactionStatus_utime_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        ZebraTransactionStatus *arg1 ;
        long result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: ZebraTransactionStatus_utime_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ZebraTransactionStatus,0) < 0) {
                SWIG_croak("Type error in argument 1 of ZebraTransactionStatus_utime_get. Expected _p_ZebraTransactionStatus");
            }
        }
        result = (long) ((arg1)->utime);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ZebraTransactionStatus_stime_set) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        ZebraTransactionStatus *arg1 ;
        long arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: ZebraTransactionStatus_stime_set(self,stime);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ZebraTransactionStatus,0) < 0) {
                SWIG_croak("Type error in argument 1 of ZebraTransactionStatus_stime_set. Expected _p_ZebraTransactionStatus");
            }
        }
        arg2 = (long) SvIV(ST(1));
        if (arg1) (arg1)->stime = arg2;
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_ZebraTransactionStatus_stime_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        ZebraTransactionStatus *arg1 ;
        long result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: ZebraTransactionStatus_stime_get(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ZebraTransactionStatus,0) < 0) {
                SWIG_croak("Type error in argument 1 of ZebraTransactionStatus_stime_get. Expected _p_ZebraTransactionStatus");
            }
        }
        result = (long) ((arg1)->stime);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_new_ZebraTransactionStatus) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        ZebraTransactionStatus *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 0) || (items > 0)) {
            SWIG_croak("Usage: new_ZebraTransactionStatus();");
        }
        result = (ZebraTransactionStatus *)(ZebraTransactionStatus *) calloc(1, sizeof(ZebraTransactionStatus));
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_ZebraTransactionStatus,0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_delete_ZebraTransactionStatus) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        ZebraTransactionStatus *arg1 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: delete_ZebraTransactionStatus(self);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ZebraTransactionStatus,0) < 0) {
                SWIG_croak("Type error in argument 1 of delete_ZebraTransactionStatus. Expected _p_ZebraTransactionStatus");
            }
        }
        free((char *) arg1);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_init__SWIG_0) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        int argvi = 0;
        dXSARGS;
        
        if ((items < 0) || (items > 0)) {
            SWIG_croak("Usage: init();");
        }
        init();
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_DESTROY) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        int argvi = 0;
        dXSARGS;
        
        if ((items < 0) || (items > 0)) {
            SWIG_croak("Usage: DESTROY();");
        }
        DESTROY();
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_logLevel) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        int arg1 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: logLevel(level);");
        }
        arg1 = (int) SvIV(ST(0));
        yaz_log_init_level(arg1);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_logFile) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        char *arg1 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: logFile(fname);");
        }
        if (!SvOK((SV*) ST(0))) arg1 = 0;
        else arg1 = (char *) SvPV(ST(0), PL_na);
        yaz_log_init_file((char const *)arg1);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_logMsg) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        int arg1 ;
        char *arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: logMsg(level,message);");
        }
        arg1 = (int) SvIV(ST(0));
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        logMsg(arg1,(char const *)arg2);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_logPrefix) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        char *arg1 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: logPrefix(prefix);");
        }
        if (!SvOK((SV*) ST(0))) arg1 = 0;
        else arg1 = (char *) SvPV(ST(0), PL_na);
        yaz_log_init_prefix((char const *)arg1);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_logPrefix2) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        char *arg1 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: logPrefix2(prefix);");
        }
        if (!SvOK((SV*) ST(0))) arg1 = 0;
        else arg1 = (char *) SvPV(ST(0), PL_na);
        yaz_log_init_prefix2((char const *)arg1);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_odr_createmem) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        int arg1 ;
        ODR result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: odr_createmem(direction);");
        }
        arg1 = (int) SvIV(ST(0));
        result = odr_createmem(arg1);
        
        {
            ODR * resultobj = (ODR *) malloc(sizeof(ODR));
            memmove(resultobj, &result, sizeof(ODR));
            ST(argvi) = sv_newmortal();
            SWIG_MakePtr(ST(argvi++), (void *) resultobj, SWIGTYPE_p_ODR,0);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_odr_reset) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        ODR arg1 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: odr_reset(o);");
        }
        {
            ODR * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_ODR,0) < 0) {
                SWIG_croak("Type error in argument 1 of odr_reset. Expected _p_ODR");
            }
            arg1 = *argp;
        }
        odr_reset(arg1);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_odr_destroy) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        ODR arg1 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: odr_destroy(o);");
        }
        {
            ODR * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_ODR,0) < 0) {
                SWIG_croak("Type error in argument 1 of odr_destroy. Expected _p_ODR");
            }
            arg1 = *argp;
        }
        odr_destroy(arg1);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_odr_malloc) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        ODR arg1 ;
        int arg2 ;
        void *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: odr_malloc(o,size);");
        }
        {
            ODR * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_ODR,0) < 0) {
                SWIG_croak("Type error in argument 1 of odr_malloc. Expected _p_ODR");
            }
            arg1 = *argp;
        }
        arg2 = (int) SvIV(ST(1));
        result = (void *)odr_malloc(arg1,arg2);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_void,0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_start) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        char *arg1 ;
        ZebraService result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: start(configName);");
        }
        if (!SvOK((SV*) ST(0))) arg1 = 0;
        else arg1 = (char *) SvPV(ST(0), PL_na);
        result = zebra_start((char const *)arg1);
        
        {
            ZebraService * resultobj = (ZebraService *) malloc(sizeof(ZebraService));
            memmove(resultobj, &result, sizeof(ZebraService));
            ST(argvi) = sv_newmortal();
            SWIG_MakePtr(ST(argvi++), (void *) resultobj, SWIGTYPE_p_ZebraService,0);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_open) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        ZebraService arg1 ;
        ZebraHandle result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: open(zs);");
        }
        {
            ZebraService * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_ZebraService,0) < 0) {
                SWIG_croak("Type error in argument 1 of open. Expected _p_ZebraService");
            }
            arg1 = *argp;
        }
        result = zebra_open(arg1);
        
        {
            ZebraHandle * resultobj = (ZebraHandle *) malloc(sizeof(ZebraHandle));
            memmove(resultobj, &result, sizeof(ZebraHandle));
            ST(argvi) = sv_newmortal();
            SWIG_MakePtr(ST(argvi++), (void *) resultobj, SWIGTYPE_p_ZebraHandle,0);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_close) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        ZebraHandle arg1 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: close(zh);");
        }
        {
            ZebraHandle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_ZebraHandle,0) < 0) {
                SWIG_croak("Type error in argument 1 of close. Expected _p_ZebraHandle");
            }
            arg1 = *argp;
        }
        zebra_close(arg1);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_stop) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        ZebraService arg1 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: stop(zs);");
        }
        {
            ZebraService * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_ZebraService,0) < 0) {
                SWIG_croak("Type error in argument 1 of stop. Expected _p_ZebraService");
            }
            arg1 = *argp;
        }
        zebra_stop(arg1);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_errCode) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        ZebraHandle arg1 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: errCode(zh);");
        }
        {
            ZebraHandle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_ZebraHandle,0) < 0) {
                SWIG_croak("Type error in argument 1 of errCode. Expected _p_ZebraHandle");
            }
            arg1 = *argp;
        }
        result = (int)zebra_errCode(arg1);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_errString) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        ZebraHandle arg1 ;
        char *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: errString(zh);");
        }
        {
            ZebraHandle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_ZebraHandle,0) < 0) {
                SWIG_croak("Type error in argument 1 of errString. Expected _p_ZebraHandle");
            }
            arg1 = *argp;
        }
        result = (char *)zebra_errString(arg1);
        
        ST(argvi) = sv_newmortal();
        if (result) {
            sv_setpv((SV*)ST(argvi++), (char *) result);
        }else {
            sv_setsv((SV*)ST(argvi++), &PL_sv_undef);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_errAdd) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        ZebraHandle arg1 ;
        char *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: errAdd(zh);");
        }
        {
            ZebraHandle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_ZebraHandle,0) < 0) {
                SWIG_croak("Type error in argument 1 of errAdd. Expected _p_ZebraHandle");
            }
            arg1 = *argp;
        }
        result = (char *)zebra_errAdd(arg1);
        
        ST(argvi) = sv_newmortal();
        if (result) {
            sv_setpv((SV*)ST(argvi++), (char *) result);
        }else {
            sv_setsv((SV*)ST(argvi++), &PL_sv_undef);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_init_recordGroup) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        recordGroup *arg1 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: init_recordGroup(rg);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_recordGroup,0) < 0) {
                SWIG_croak("Type error in argument 1 of init_recordGroup. Expected _p_recordGroup");
            }
        }
        init_recordGroup(arg1);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_res_get_recordGroup) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        ZebraHandle arg1 ;
        recordGroup *arg2 ;
        char *arg3 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: res_get_recordGroup(zh,rg,ext);");
        }
        {
            ZebraHandle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_ZebraHandle,0) < 0) {
                SWIG_croak("Type error in argument 1 of res_get_recordGroup. Expected _p_ZebraHandle");
            }
            arg1 = *argp;
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_recordGroup,0) < 0) {
                SWIG_croak("Type error in argument 2 of res_get_recordGroup. Expected _p_recordGroup");
            }
        }
        if (!SvOK((SV*) ST(2))) arg3 = 0;
        else arg3 = (char *) SvPV(ST(2), PL_na);
        res_get_recordGroup(arg1,arg2,(char const *)arg3);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_set_group) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        ZebraHandle arg1 ;
        struct recordGroup *arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: set_group(zh,rg);");
        }
        {
            ZebraHandle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_ZebraHandle,0) < 0) {
                SWIG_croak("Type error in argument 1 of set_group. Expected _p_ZebraHandle");
            }
            arg1 = *argp;
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_recordGroup,0) < 0) {
                SWIG_croak("Type error in argument 2 of set_group. Expected _p_recordGroup");
            }
        }
        zebra_set_group(arg1,arg2);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_select_database) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        ZebraHandle arg1 ;
        char *arg2 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: select_database(zh,basename);");
        }
        {
            ZebraHandle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_ZebraHandle,0) < 0) {
                SWIG_croak("Type error in argument 1 of select_database. Expected _p_ZebraHandle");
            }
            arg1 = *argp;
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        result = (int)zebra_select_database(arg1,(char const *)arg2);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_select_databases) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        ZebraHandle arg1 ;
        int arg2 ;
        char **arg3 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: select_databases(zh,num_bases,basenames);");
        }
        {
            ZebraHandle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_ZebraHandle,0) < 0) {
                SWIG_croak("Type error in argument 1 of select_databases. Expected _p_ZebraHandle");
            }
            arg1 = *argp;
        }
        arg2 = (int) SvIV(ST(1));
        {
            AV *tempav;
            I32 len;
            int i;
            SV  **tv;
            STRLEN na;
            if (!SvROK(ST(2)))
            croak("Argument 3 is not a reference.");
            if (SvTYPE(SvRV(ST(2))) != SVt_PVAV)
            croak("Argument 3 is not an array.");
            tempav = (AV*)SvRV(ST(2));
            len = av_len(tempav);
            arg3 = (char **) malloc((len+2)*sizeof(char *));
            for (i = 0; i <= len; i++) {
                tv = av_fetch(tempav, i, 0);	
                arg3[i] = (char *) SvPV(*tv,na);
            }
            arg3[i] = NULL;
        }
        result = (int)zebra_select_databases(arg1,arg2,(char const **)arg3);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        {
            free(arg3);
        }
        XSRETURN(argvi);
        fail:
        {
            free(arg3);
        }
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_begin_trans) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        ZebraHandle arg1 ;
        int arg2 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: begin_trans(zh,rw);");
        }
        {
            ZebraHandle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_ZebraHandle,0) < 0) {
                SWIG_croak("Type error in argument 1 of begin_trans. Expected _p_ZebraHandle");
            }
            arg1 = *argp;
        }
        arg2 = (int) SvIV(ST(1));
        result = (int)zebra_begin_trans(arg1,arg2);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_end_trans) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        ZebraHandle arg1 ;
        ZebraTransactionStatus *arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: end_trans(zh,stat);");
        }
        {
            ZebraHandle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_ZebraHandle,0) < 0) {
                SWIG_croak("Type error in argument 1 of end_trans. Expected _p_ZebraHandle");
            }
            arg1 = *argp;
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_ZebraTransactionStatus,0) < 0) {
                SWIG_croak("Type error in argument 2 of end_trans. Expected _p_ZebraTransactionStatus");
            }
        }
        zebra_end_transaction(arg1,arg2);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_trans_no) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        ZebraHandle arg1 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: trans_no(zh);");
        }
        {
            ZebraHandle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_ZebraHandle,0) < 0) {
                SWIG_croak("Type error in argument 1 of trans_no. Expected _p_ZebraHandle");
            }
            arg1 = *argp;
        }
        result = (int)zebra_trans_no(arg1);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_commit) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        ZebraHandle arg1 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: commit(zh);");
        }
        {
            ZebraHandle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_ZebraHandle,0) < 0) {
                SWIG_croak("Type error in argument 1 of commit. Expected _p_ZebraHandle");
            }
            arg1 = *argp;
        }
        result = (int)zebra_commit(arg1);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_get_shadow_enable) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        ZebraHandle arg1 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: get_shadow_enable(zh);");
        }
        {
            ZebraHandle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_ZebraHandle,0) < 0) {
                SWIG_croak("Type error in argument 1 of get_shadow_enable. Expected _p_ZebraHandle");
            }
            arg1 = *argp;
        }
        result = (int)zebra_get_shadow_enable(arg1);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_set_shadow_enable) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        ZebraHandle arg1 ;
        int arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: set_shadow_enable(zh,value);");
        }
        {
            ZebraHandle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_ZebraHandle,0) < 0) {
                SWIG_croak("Type error in argument 1 of set_shadow_enable. Expected _p_ZebraHandle");
            }
            arg1 = *argp;
        }
        arg2 = (int) SvIV(ST(1));
        zebra_set_shadow_enable(arg1,arg2);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_init__SWIG_1) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        ZebraHandle arg1 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: init(zh);");
        }
        {
            ZebraHandle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_ZebraHandle,0) < 0) {
                SWIG_croak("Type error in argument 1 of init. Expected _p_ZebraHandle");
            }
            arg1 = *argp;
        }
        result = (int)zebra_init(arg1);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_init) {
    dXSARGS;
    
    if (items == 0) {
        int _v;
        (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_init__SWIG_0); return;
    }
    if (items == 1) {
        int _v;
        {
            void *tmp;
            if (SWIG_ConvertPtr(ST(0), (void **) &tmp, SWIGTYPE_p_ZebraHandle, 0) == -1) {
                _v = 0;
            }else {
                _v = 1;
            }
        }
        if (_v) {
            (*PL_markstack_ptr++);SWIG_CALLXS(_wrap_init__SWIG_1); return;
        }
    }
    
    croak("No matching function for overloaded 'init'");
    XSRETURN(0);
}


XS(_wrap_compact) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        ZebraHandle arg1 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: compact(zh);");
        }
        {
            ZebraHandle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_ZebraHandle,0) < 0) {
                SWIG_croak("Type error in argument 1 of compact. Expected _p_ZebraHandle");
            }
            arg1 = *argp;
        }
        result = (int)zebra_compact(arg1);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_repository_update) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        ZebraHandle arg1 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: repository_update(zh);");
        }
        {
            ZebraHandle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_ZebraHandle,0) < 0) {
                SWIG_croak("Type error in argument 1 of repository_update. Expected _p_ZebraHandle");
            }
            arg1 = *argp;
        }
        zebra_repository_update(arg1);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_repository_delete) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        ZebraHandle arg1 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: repository_delete(zh);");
        }
        {
            ZebraHandle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_ZebraHandle,0) < 0) {
                SWIG_croak("Type error in argument 1 of repository_delete. Expected _p_ZebraHandle");
            }
            arg1 = *argp;
        }
        zebra_repository_delete(arg1);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_repository_show) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        ZebraHandle arg1 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: repository_show(zh);");
        }
        {
            ZebraHandle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_ZebraHandle,0) < 0) {
                SWIG_croak("Type error in argument 1 of repository_show. Expected _p_ZebraHandle");
            }
            arg1 = *argp;
        }
        zebra_repository_show(arg1);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_insert_record) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        ZebraHandle arg1 ;
        recordGroup *arg2 ;
        char *arg3 ;
        int *arg4 ;
        char *arg5 ;
        char *arg6 ;
        char *arg7 ;
        int arg8 ;
        int arg9 ;
        int result;
        int dvalue4 ;
        int argvi = 0;
        SV * _saved[1] ;
        dXSARGS;
        
        if ((items < 9) || (items > 9)) {
            SWIG_croak("Usage: insert_record(zh,rGroup,recordType,sysno,match,fname,buf,buf_size,force_update);");
        }
        {
            ZebraHandle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_ZebraHandle,0) < 0) {
                SWIG_croak("Type error in argument 1 of insert_record. Expected _p_ZebraHandle");
            }
            arg1 = *argp;
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_recordGroup,0) < 0) {
                SWIG_croak("Type error in argument 2 of insert_record. Expected _p_recordGroup");
            }
        }
        if (!SvOK((SV*) ST(2))) arg3 = 0;
        else arg3 = (char *) SvPV(ST(2), PL_na);
        {
            SV *tempsv;
            if (!SvROK(ST(3))) {
                SWIG_croak("expected a reference");
            }
            tempsv = SvRV(ST(3));
            if (!SvIOK(tempsv)) {
                SWIG_croak("expected a integer reference");
            }
            dvalue4 = SvIV(tempsv);
            arg4 = &dvalue4;
        }
        if (!SvOK((SV*) ST(4))) arg5 = 0;
        else arg5 = (char *) SvPV(ST(4), PL_na);
        if (!SvOK((SV*) ST(5))) arg6 = 0;
        else arg6 = (char *) SvPV(ST(5), PL_na);
        if (!SvOK((SV*) ST(6))) arg7 = 0;
        else arg7 = (char *) SvPV(ST(6), PL_na);
        arg8 = (int) SvIV(ST(7));
        arg9 = (int) SvIV(ST(8));
        _saved[0] = ST(3);
        result = (int)zebra_insert_record(arg1,arg2,(char const *)arg3,arg4,(char const *)arg5,(char const *)arg6,(char const *)arg7,arg8,arg9);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        {
            SV *tempsv;
            tempsv = SvRV(_saved[0]);
            sv_setiv(tempsv, (IV) *arg4);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_update_record) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        ZebraHandle arg1 ;
        recordGroup *arg2 ;
        char *arg3 ;
        int *arg4 ;
        char *arg5 ;
        char *arg6 ;
        char *arg7 ;
        int arg8 ;
        int arg9 ;
        int result;
        int dvalue4 ;
        int argvi = 0;
        SV * _saved[1] ;
        dXSARGS;
        
        if ((items < 9) || (items > 9)) {
            SWIG_croak("Usage: update_record(zh,rGroup,recordType,sysno,match,fname,buf,buf_size,force_update);");
        }
        {
            ZebraHandle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_ZebraHandle,0) < 0) {
                SWIG_croak("Type error in argument 1 of update_record. Expected _p_ZebraHandle");
            }
            arg1 = *argp;
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_recordGroup,0) < 0) {
                SWIG_croak("Type error in argument 2 of update_record. Expected _p_recordGroup");
            }
        }
        if (!SvOK((SV*) ST(2))) arg3 = 0;
        else arg3 = (char *) SvPV(ST(2), PL_na);
        {
            SV *tempsv;
            if (!SvROK(ST(3))) {
                SWIG_croak("expected a reference");
            }
            tempsv = SvRV(ST(3));
            if (!SvIOK(tempsv)) {
                SWIG_croak("expected a integer reference");
            }
            dvalue4 = SvIV(tempsv);
            arg4 = &dvalue4;
        }
        if (!SvOK((SV*) ST(4))) arg5 = 0;
        else arg5 = (char *) SvPV(ST(4), PL_na);
        if (!SvOK((SV*) ST(5))) arg6 = 0;
        else arg6 = (char *) SvPV(ST(5), PL_na);
        if (!SvOK((SV*) ST(6))) arg7 = 0;
        else arg7 = (char *) SvPV(ST(6), PL_na);
        arg8 = (int) SvIV(ST(7));
        arg9 = (int) SvIV(ST(8));
        _saved[0] = ST(3);
        result = (int)zebra_update_record(arg1,arg2,(char const *)arg3,arg4,(char const *)arg5,(char const *)arg6,(char const *)arg7,arg8,arg9);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        {
            SV *tempsv;
            tempsv = SvRV(_saved[0]);
            sv_setiv(tempsv, (IV) *arg4);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_delete_record) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        ZebraHandle arg1 ;
        recordGroup *arg2 ;
        char *arg3 ;
        int *arg4 ;
        char *arg5 ;
        char *arg6 ;
        char *arg7 ;
        int arg8 ;
        int arg9 ;
        int result;
        int dvalue4 ;
        int argvi = 0;
        SV * _saved[1] ;
        dXSARGS;
        
        if ((items < 9) || (items > 9)) {
            SWIG_croak("Usage: delete_record(zh,rGroup,recordType,sysno,match,fname,buf,buf_size,force_update);");
        }
        {
            ZebraHandle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_ZebraHandle,0) < 0) {
                SWIG_croak("Type error in argument 1 of delete_record. Expected _p_ZebraHandle");
            }
            arg1 = *argp;
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_recordGroup,0) < 0) {
                SWIG_croak("Type error in argument 2 of delete_record. Expected _p_recordGroup");
            }
        }
        if (!SvOK((SV*) ST(2))) arg3 = 0;
        else arg3 = (char *) SvPV(ST(2), PL_na);
        {
            SV *tempsv;
            if (!SvROK(ST(3))) {
                SWIG_croak("expected a reference");
            }
            tempsv = SvRV(ST(3));
            if (!SvIOK(tempsv)) {
                SWIG_croak("expected a integer reference");
            }
            dvalue4 = SvIV(tempsv);
            arg4 = &dvalue4;
        }
        if (!SvOK((SV*) ST(4))) arg5 = 0;
        else arg5 = (char *) SvPV(ST(4), PL_na);
        if (!SvOK((SV*) ST(5))) arg6 = 0;
        else arg6 = (char *) SvPV(ST(5), PL_na);
        if (!SvOK((SV*) ST(6))) arg7 = 0;
        else arg7 = (char *) SvPV(ST(6), PL_na);
        arg8 = (int) SvIV(ST(7));
        arg9 = (int) SvIV(ST(8));
        _saved[0] = ST(3);
        result = (int)zebra_delete_record(arg1,arg2,(char const *)arg3,arg4,(char const *)arg5,(char const *)arg6,(char const *)arg7,arg8,arg9);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        {
            SV *tempsv;
            tempsv = SvRV(_saved[0]);
            sv_setiv(tempsv, (IV) *arg4);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_search_PQF) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        ZebraHandle arg1 ;
        char *arg2 ;
        char *arg3 ;
        int *arg4 ;
        int result;
        int dvalue4 ;
        int argvi = 0;
        SV * _saved[1] ;
        dXSARGS;
        
        if ((items < 4) || (items > 4)) {
            SWIG_croak("Usage: search_PQF(zh,pqf_query,setname,hits);");
        }
        {
            ZebraHandle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_ZebraHandle,0) < 0) {
                SWIG_croak("Type error in argument 1 of search_PQF. Expected _p_ZebraHandle");
            }
            arg1 = *argp;
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        if (!SvOK((SV*) ST(2))) arg3 = 0;
        else arg3 = (char *) SvPV(ST(2), PL_na);
        {
            SV *tempsv;
            if (!SvROK(ST(3))) {
                SWIG_croak("expected a reference");
            }
            tempsv = SvRV(ST(3));
            if (!SvIOK(tempsv)) {
                SWIG_croak("expected a integer reference");
            }
            dvalue4 = SvIV(tempsv);
            arg4 = &dvalue4;
        }
        _saved[0] = ST(3);
        result = (int)zebra_search_PQF(arg1,(char const *)arg2,(char const *)arg3,arg4);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        {
            SV *tempsv;
            tempsv = SvRV(_saved[0]);
            sv_setiv(tempsv, (IV) *arg4);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_cql_transform_open_fname) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        char *arg1 ;
        cql_transform_t result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: cql_transform_open_fname(fname);");
        }
        if (!SvOK((SV*) ST(0))) arg1 = 0;
        else arg1 = (char *) SvPV(ST(0), PL_na);
        result = cql_transform_open_fname((char const *)arg1);
        
        {
            cql_transform_t * resultobj = (cql_transform_t *) malloc(sizeof(cql_transform_t));
            memmove(resultobj, &result, sizeof(cql_transform_t));
            ST(argvi) = sv_newmortal();
            SWIG_MakePtr(ST(argvi++), (void *) resultobj, SWIGTYPE_p_cql_transform_t,0);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_cql_transform_close) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        cql_transform_t arg1 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: cql_transform_close(ct);");
        }
        {
            cql_transform_t * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_cql_transform_t,0) < 0) {
                SWIG_croak("Type error in argument 1 of cql_transform_close. Expected _p_cql_transform_t");
            }
            arg1 = *argp;
        }
        cql_transform_close(arg1);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_cql_transform_error) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        cql_transform_t arg1 ;
        char **arg2 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: cql_transform_error(ct,addinfo);");
        }
        {
            cql_transform_t * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_cql_transform_t,0) < 0) {
                SWIG_croak("Type error in argument 1 of cql_transform_error. Expected _p_cql_transform_t");
            }
            arg1 = *argp;
        }
        {
            AV *tempav;
            I32 len;
            int i;
            SV  **tv;
            STRLEN na;
            if (!SvROK(ST(1)))
            croak("Argument 2 is not a reference.");
            if (SvTYPE(SvRV(ST(1))) != SVt_PVAV)
            croak("Argument 2 is not an array.");
            tempav = (AV*)SvRV(ST(1));
            len = av_len(tempav);
            arg2 = (char **) malloc((len+2)*sizeof(char *));
            for (i = 0; i <= len; i++) {
                tv = av_fetch(tempav, i, 0);	
                arg2[i] = (char *) SvPV(*tv,na);
            }
            arg2[i] = NULL;
        }
        result = (int)cql_transform_error(arg1,(char const **)arg2);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        {
            free(arg2);
        }
        XSRETURN(argvi);
        fail:
        {
            free(arg2);
        }
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_cql2pqf) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        cql_transform_t arg1 ;
        char *arg2 ;
        char *arg3 ;
        int arg4 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 4) || (items > 4)) {
            SWIG_croak("Usage: cql2pqf(ct,query,res,len);");
        }
        {
            cql_transform_t * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_cql_transform_t,0) < 0) {
                SWIG_croak("Type error in argument 1 of cql2pqf. Expected _p_cql_transform_t");
            }
            arg1 = *argp;
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        if (!SvOK((SV*) ST(2))) arg3 = 0;
        else arg3 = (char *) SvPV(ST(2), PL_na);
        arg4 = (int) SvIV(ST(3));
        result = (int)zebra_cql2pqf(arg1,(char const *)arg2,arg3,arg4);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_records_retrieve) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        ZebraHandle arg1 ;
        ODR arg2 ;
        char *arg3 ;
        char *arg4 ;
        char *arg5 ;
        char *arg6 ;
        int arg7 ;
        int arg8 ;
        RetrievalObj *arg9 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 9) || (items > 9)) {
            SWIG_croak("Usage: records_retrieve(zh,stream,setname,a_eset,a_schema,a_format,from,to,res);");
        }
        {
            ZebraHandle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_ZebraHandle,0) < 0) {
                SWIG_croak("Type error in argument 1 of records_retrieve. Expected _p_ZebraHandle");
            }
            arg1 = *argp;
        }
        {
            ODR * argp;
            if (SWIG_ConvertPtr(ST(1),(void **) &argp, SWIGTYPE_p_ODR,0) < 0) {
                SWIG_croak("Type error in argument 2 of records_retrieve. Expected _p_ODR");
            }
            arg2 = *argp;
        }
        if (!SvOK((SV*) ST(2))) arg3 = 0;
        else arg3 = (char *) SvPV(ST(2), PL_na);
        if (!SvOK((SV*) ST(3))) arg4 = 0;
        else arg4 = (char *) SvPV(ST(3), PL_na);
        if (!SvOK((SV*) ST(4))) arg5 = 0;
        else arg5 = (char *) SvPV(ST(4), PL_na);
        if (!SvOK((SV*) ST(5))) arg6 = 0;
        else arg6 = (char *) SvPV(ST(5), PL_na);
        arg7 = (int) SvIV(ST(6));
        arg8 = (int) SvIV(ST(7));
        {
            if (SWIG_ConvertPtr(ST(8), (void **) &arg9, SWIGTYPE_p_RetrievalObj,0) < 0) {
                SWIG_croak("Type error in argument 9 of records_retrieve. Expected _p_RetrievalObj");
            }
        }
        records_retrieve(arg1,arg2,(char const *)arg3,(char const *)arg4,(char const *)arg5,(char const *)arg6,arg7,arg8,arg9);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_record_retrieve) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        RetrievalObj *arg1 ;
        ODR arg2 ;
        RetrievalRecord *arg3 ;
        int arg4 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 4) || (items > 4)) {
            SWIG_croak("Usage: record_retrieve(ro,stream,res,pos);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_RetrievalObj,0) < 0) {
                SWIG_croak("Type error in argument 1 of record_retrieve. Expected _p_RetrievalObj");
            }
        }
        {
            ODR * argp;
            if (SWIG_ConvertPtr(ST(1),(void **) &argp, SWIGTYPE_p_ODR,0) < 0) {
                SWIG_croak("Type error in argument 2 of record_retrieve. Expected _p_ODR");
            }
            arg2 = *argp;
        }
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_RetrievalRecord,0) < 0) {
                SWIG_croak("Type error in argument 3 of record_retrieve. Expected _p_RetrievalRecord");
            }
        }
        arg4 = (int) SvIV(ST(3));
        record_retrieve(arg1,arg2,arg3,arg4);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_deleteResultSet) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        ZebraHandle arg1 ;
        int arg2 ;
        int arg3 ;
        char **arg4 ;
        int *arg5 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 5) || (items > 5)) {
            SWIG_croak("Usage: deleteResultSet(zh,function,num_setnames,setnames,statuses);");
        }
        {
            ZebraHandle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_ZebraHandle,0) < 0) {
                SWIG_croak("Type error in argument 1 of deleteResultSet. Expected _p_ZebraHandle");
            }
            arg1 = *argp;
        }
        arg2 = (int) SvIV(ST(1));
        arg3 = (int) SvIV(ST(2));
        {
            AV *tempav;
            I32 len;
            int i;
            SV  **tv;
            STRLEN na;
            if (!SvROK(ST(3)))
            croak("Argument 4 is not a reference.");
            if (SvTYPE(SvRV(ST(3))) != SVt_PVAV)
            croak("Argument 4 is not an array.");
            tempav = (AV*)SvRV(ST(3));
            len = av_len(tempav);
            arg4 = (char **) malloc((len+2)*sizeof(char *));
            for (i = 0; i <= len; i++) {
                tv = av_fetch(tempav, i, 0);	
                arg4[i] = (char *) SvPV(*tv,na);
            }
            arg4[i] = NULL;
        }
        {
            int i;
            if (!SvIOK(ST(4))) 
            croak("Argument 5 is not an integer.");
            i = SvIV(ST(4));
            arg5 = &i;
        }
        result = (int)zebra_deleleResultSet(arg1,arg2,arg3,arg4,arg5);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        {
            free(arg4);
        }
        XSRETURN(argvi);
        fail:
        {
            free(arg4);
        }
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_resultSetTerms) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        ZebraHandle arg1 ;
        char *arg2 ;
        int arg3 ;
        int *arg4 ;
        int *arg5 ;
        char *arg6 ;
        int *arg7 ;
        int result;
        int dvalue4 ;
        int dvalue5 ;
        int dvalue7 ;
        int argvi = 0;
        SV * _saved[3] ;
        dXSARGS;
        
        if ((items < 7) || (items > 7)) {
            SWIG_croak("Usage: resultSetTerms(zh,setname,no,REFERENCE,REFERENCE,out,REFERENCE);");
        }
        {
            ZebraHandle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_ZebraHandle,0) < 0) {
                SWIG_croak("Type error in argument 1 of resultSetTerms. Expected _p_ZebraHandle");
            }
            arg1 = *argp;
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        arg3 = (int) SvIV(ST(2));
        {
            SV *tempsv;
            if (!SvROK(ST(3))) {
                SWIG_croak("expected a reference");
            }
            tempsv = SvRV(ST(3));
            if (!SvIOK(tempsv)) {
                SWIG_croak("expected a integer reference");
            }
            dvalue4 = SvIV(tempsv);
            arg4 = &dvalue4;
        }
        {
            SV *tempsv;
            if (!SvROK(ST(4))) {
                SWIG_croak("expected a reference");
            }
            tempsv = SvRV(ST(4));
            if (!SvIOK(tempsv)) {
                SWIG_croak("expected a integer reference");
            }
            dvalue5 = SvIV(tempsv);
            arg5 = &dvalue5;
        }
        if (!SvOK((SV*) ST(5))) arg6 = 0;
        else arg6 = (char *) SvPV(ST(5), PL_na);
        {
            SV *tempsv;
            if (!SvROK(ST(6))) {
                SWIG_croak("expected a reference");
            }
            tempsv = SvRV(ST(6));
            if (!SvIOK(tempsv)) {
                SWIG_croak("expected a integer reference");
            }
            dvalue7 = SvIV(tempsv);
            arg7 = &dvalue7;
        }
        _saved[0] = ST(3);
        _saved[1] = ST(4);
        _saved[2] = ST(6);
        result = (int)zebra_resultSetTerms(arg1,(char const *)arg2,arg3,arg4,arg5,arg6,arg7);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        {
            SV *tempsv;
            tempsv = SvRV(_saved[0]);
            sv_setiv(tempsv, (IV) *arg4);
        }
        {
            SV *tempsv;
            tempsv = SvRV(_saved[1]);
            sv_setiv(tempsv, (IV) *arg5);
        }
        {
            SV *tempsv;
            tempsv = SvRV(_saved[2]);
            sv_setiv(tempsv, (IV) *arg7);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_sort) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        ZebraHandle arg1 ;
        ODR arg2 ;
        char *arg3 ;
        char *arg4 ;
        char **arg5 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 5) || (items > 5)) {
            SWIG_croak("Usage: sort(zh,stream,sort_spec,output_setname,input_setnames);");
        }
        {
            ZebraHandle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_ZebraHandle,0) < 0) {
                SWIG_croak("Type error in argument 1 of sort. Expected _p_ZebraHandle");
            }
            arg1 = *argp;
        }
        {
            ODR * argp;
            if (SWIG_ConvertPtr(ST(1),(void **) &argp, SWIGTYPE_p_ODR,0) < 0) {
                SWIG_croak("Type error in argument 2 of sort. Expected _p_ODR");
            }
            arg2 = *argp;
        }
        if (!SvOK((SV*) ST(2))) arg3 = 0;
        else arg3 = (char *) SvPV(ST(2), PL_na);
        if (!SvOK((SV*) ST(3))) arg4 = 0;
        else arg4 = (char *) SvPV(ST(3), PL_na);
        {
            AV *tempav;
            I32 len;
            int i;
            SV  **tv;
            STRLEN na;
            if (!SvROK(ST(4)))
            croak("Argument 5 is not a reference.");
            if (SvTYPE(SvRV(ST(4))) != SVt_PVAV)
            croak("Argument 5 is not an array.");
            tempav = (AV*)SvRV(ST(4));
            len = av_len(tempav);
            arg5 = (char **) malloc((len+2)*sizeof(char *));
            for (i = 0; i <= len; i++) {
                tv = av_fetch(tempav, i, 0);	
                arg5[i] = (char *) SvPV(*tv,na);
            }
            arg5[i] = NULL;
        }
        result = (int)zebra_sort_by_specstr(arg1,arg2,(char const *)arg3,(char const *)arg4,(char const **)arg5);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        {
            free(arg5);
        }
        XSRETURN(argvi);
        fail:
        {
            free(arg5);
        }
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_scan_PQF) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        ZebraHandle arg1 ;
        ScanObj *arg2 ;
        ODR arg3 ;
        char *arg4 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 4) || (items > 4)) {
            SWIG_croak("Usage: scan_PQF(zh,so,stream,pqf_query);");
        }
        {
            ZebraHandle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_ZebraHandle,0) < 0) {
                SWIG_croak("Type error in argument 1 of scan_PQF. Expected _p_ZebraHandle");
            }
            arg1 = *argp;
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_ScanObj,0) < 0) {
                SWIG_croak("Type error in argument 2 of scan_PQF. Expected _p_ScanObj");
            }
        }
        {
            ODR * argp;
            if (SWIG_ConvertPtr(ST(2),(void **) &argp, SWIGTYPE_p_ODR,0) < 0) {
                SWIG_croak("Type error in argument 3 of scan_PQF. Expected _p_ODR");
            }
            arg3 = *argp;
        }
        if (!SvOK((SV*) ST(3))) arg4 = 0;
        else arg4 = (char *) SvPV(ST(3), PL_na);
        zebra_scan_PQF(arg1,arg2,arg3,(char const *)arg4);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_getScanEntry) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        ScanObj *arg1 ;
        int arg2 ;
        scanEntry *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: getScanEntry(so,pos);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_ScanObj,0) < 0) {
                SWIG_croak("Type error in argument 1 of getScanEntry. Expected _p_ScanObj");
            }
        }
        arg2 = (int) SvIV(ST(1));
        result = (scanEntry *)getScanEntry(arg1,arg2);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_scanEntry,0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_nmem_create) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        NMEM result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 0) || (items > 0)) {
            SWIG_croak("Usage: nmem_create();");
        }
        result = nmem_create();
        
        {
            NMEM * resultobj = (NMEM *) malloc(sizeof(NMEM));
            memmove(resultobj, &result, sizeof(NMEM));
            ST(argvi) = sv_newmortal();
            SWIG_MakePtr(ST(argvi++), (void *) resultobj, SWIGTYPE_p_NMEM,0);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_nmem_destroy) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        NMEM arg1 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: nmem_destroy(handle);");
        }
        {
            NMEM * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_NMEM,0) < 0) {
                SWIG_croak("Type error in argument 1 of nmem_destroy. Expected _p_NMEM");
            }
            arg1 = *argp;
        }
        nmem_destroy(arg1);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_create) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 0) || (items > 0)) {
            SWIG_croak("Usage: data1_create();");
        }
        result = data1_create();
        
        {
            data1_handle * resultobj = (data1_handle *) malloc(sizeof(data1_handle));
            memmove(resultobj, &result, sizeof(data1_handle));
            ST(argvi) = sv_newmortal();
            SWIG_MakePtr(ST(argvi++), (void *) resultobj, SWIGTYPE_p_data1_handle,0);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_createx) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        int arg1 ;
        data1_handle result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: data1_createx(flags);");
        }
        arg1 = (int) SvIV(ST(0));
        result = data1_createx(arg1);
        
        {
            data1_handle * resultobj = (data1_handle *) malloc(sizeof(data1_handle));
            memmove(resultobj, &result, sizeof(data1_handle));
            ST(argvi) = sv_newmortal();
            SWIG_MakePtr(ST(argvi++), (void *) resultobj, SWIGTYPE_p_data1_handle,0);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_destroy) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: data1_destroy(dh);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_destroy. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        data1_destroy(arg1);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_get_parent_tag) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        data1_node *arg2 ;
        data1_node *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: get_parent_tag(dh,n);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of get_parent_tag. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_data1_node,0) < 0) {
                SWIG_croak("Type error in argument 2 of get_parent_tag. Expected _p_data1_node");
            }
        }
        result = (data1_node *)get_parent_tag(arg1,arg2);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_data1_node,0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_read_node) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        char **arg2 ;
        NMEM arg3 ;
        data1_node *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: data1_read_node(dh,buf,m);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_read_node. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        {
            AV *tempav;
            I32 len;
            int i;
            SV  **tv;
            STRLEN na;
            if (!SvROK(ST(1)))
            croak("Argument 2 is not a reference.");
            if (SvTYPE(SvRV(ST(1))) != SVt_PVAV)
            croak("Argument 2 is not an array.");
            tempav = (AV*)SvRV(ST(1));
            len = av_len(tempav);
            arg2 = (char **) malloc((len+2)*sizeof(char *));
            for (i = 0; i <= len; i++) {
                tv = av_fetch(tempav, i, 0);	
                arg2[i] = (char *) SvPV(*tv,na);
            }
            arg2[i] = NULL;
        }
        {
            NMEM * argp;
            if (SWIG_ConvertPtr(ST(2),(void **) &argp, SWIGTYPE_p_NMEM,0) < 0) {
                SWIG_croak("Type error in argument 3 of data1_read_node. Expected _p_NMEM");
            }
            arg3 = *argp;
        }
        result = (data1_node *)data1_read_node(arg1,(char const **)arg2,arg3);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_data1_node,0);
        {
            free(arg2);
        }
        XSRETURN(argvi);
        fail:
        {
            free(arg2);
        }
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_read_nodex) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        NMEM arg2 ;
        int (*arg3)(void *) ;
        void *arg4 ;
        WRBUF arg5 ;
        data1_node *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 5) || (items > 5)) {
            SWIG_croak("Usage: data1_read_nodex(dh,m,get_byte,fh,wrbuf);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_read_nodex. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        {
            NMEM * argp;
            if (SWIG_ConvertPtr(ST(1),(void **) &argp, SWIGTYPE_p_NMEM,0) < 0) {
                SWIG_croak("Type error in argument 2 of data1_read_nodex. Expected _p_NMEM");
            }
            arg2 = *argp;
        }
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_f_p_void__int,0) < 0) {
                SWIG_croak("Type error in argument 3 of data1_read_nodex. Expected _p_f_p_void__int");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(3), (void **) &arg4, 0,0) < 0) {
                SWIG_croak("Type error in argument 4 of data1_read_nodex. Expected _p_void");
            }
        }
        {
            WRBUF * argp;
            if (SWIG_ConvertPtr(ST(4),(void **) &argp, SWIGTYPE_p_WRBUF,0) < 0) {
                SWIG_croak("Type error in argument 5 of data1_read_nodex. Expected _p_WRBUF");
            }
            arg5 = *argp;
        }
        result = (data1_node *)data1_read_nodex(arg1,arg2,arg3,arg4,arg5);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_data1_node,0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_read_record) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        int (*arg2)(void *,char *,size_t) ;
        void *arg3 ;
        NMEM arg4 ;
        data1_node *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 4) || (items > 4)) {
            SWIG_croak("Usage: data1_read_record(dh,rf,fh,m);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_read_record. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_f_p_void_p_char_size_t__int,0) < 0) {
                SWIG_croak("Type error in argument 2 of data1_read_record. Expected _p_f_p_void_p_char_size_t__int");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, 0,0) < 0) {
                SWIG_croak("Type error in argument 3 of data1_read_record. Expected _p_void");
            }
        }
        {
            NMEM * argp;
            if (SWIG_ConvertPtr(ST(3),(void **) &argp, SWIGTYPE_p_NMEM,0) < 0) {
                SWIG_croak("Type error in argument 4 of data1_read_record. Expected _p_NMEM");
            }
            arg4 = *argp;
        }
        result = (data1_node *)data1_read_record(arg1,arg2,arg3,arg4);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_data1_node,0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_read_absyn) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        char *arg2 ;
        int arg3 ;
        data1_absyn *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: data1_read_absyn(dh,file,file_must_exist);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_read_absyn. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        arg3 = (int) SvIV(ST(2));
        result = (data1_absyn *)data1_read_absyn(arg1,(char const *)arg2,arg3);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_data1_absyn,0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_gettagbynum) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        data1_tagset *arg2 ;
        int arg3 ;
        int arg4 ;
        data1_tag *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 4) || (items > 4)) {
            SWIG_croak("Usage: data1_gettagbynum(dh,s,type,value);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_gettagbynum. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_data1_tagset,0) < 0) {
                SWIG_croak("Type error in argument 2 of data1_gettagbynum. Expected _p_data1_tagset");
            }
        }
        arg3 = (int) SvIV(ST(2));
        arg4 = (int) SvIV(ST(3));
        result = (data1_tag *)data1_gettagbynum(arg1,arg2,arg3,arg4);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_data1_tag,0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_empty_tagset) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        data1_tagset *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: data1_empty_tagset(dh);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_empty_tagset. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        result = (data1_tagset *)data1_empty_tagset(arg1);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_data1_tagset,0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_read_tagset) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        char *arg2 ;
        int arg3 ;
        data1_tagset *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: data1_read_tagset(dh,file,type);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_read_tagset. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        arg3 = (int) SvIV(ST(2));
        result = (data1_tagset *)data1_read_tagset(arg1,(char const *)arg2,arg3);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_data1_tagset,0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_getelementbytagname) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        data1_absyn *arg2 ;
        data1_element *arg3 ;
        char *arg4 ;
        data1_element *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 4) || (items > 4)) {
            SWIG_croak("Usage: data1_getelementbytagname(dh,abs,parent,tagname);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_getelementbytagname. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_data1_absyn,0) < 0) {
                SWIG_croak("Type error in argument 2 of data1_getelementbytagname. Expected _p_data1_absyn");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_data1_element,0) < 0) {
                SWIG_croak("Type error in argument 3 of data1_getelementbytagname. Expected _p_data1_element");
            }
        }
        if (!SvOK((SV*) ST(3))) arg4 = 0;
        else arg4 = (char *) SvPV(ST(3), PL_na);
        result = (data1_element *)data1_getelementbytagname(arg1,arg2,arg3,(char const *)arg4);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_data1_element,0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_nodetogr) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        data1_node *arg2 ;
        int arg3 ;
        ODR arg4 ;
        int *arg5 ;
        Z_GenericRecord *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 5) || (items > 5)) {
            SWIG_croak("Usage: data1_nodetogr(dh,n,select,o,len);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_nodetogr. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_data1_node,0) < 0) {
                SWIG_croak("Type error in argument 2 of data1_nodetogr. Expected _p_data1_node");
            }
        }
        arg3 = (int) SvIV(ST(2));
        {
            ODR * argp;
            if (SWIG_ConvertPtr(ST(3),(void **) &argp, SWIGTYPE_p_ODR,0) < 0) {
                SWIG_croak("Type error in argument 4 of data1_nodetogr. Expected _p_ODR");
            }
            arg4 = *argp;
        }
        {
            if (SWIG_ConvertPtr(ST(4), (void **) &arg5, SWIGTYPE_p_int,0) < 0) {
                SWIG_croak("Type error in argument 5 of data1_nodetogr. Expected _p_int");
            }
        }
        result = (Z_GenericRecord *)data1_nodetogr(arg1,arg2,arg3,arg4,arg5);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Z_GenericRecord,0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_gettagbyname) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        data1_tagset *arg2 ;
        char *arg3 ;
        data1_tag *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: data1_gettagbyname(dh,s,name);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_gettagbyname. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_data1_tagset,0) < 0) {
                SWIG_croak("Type error in argument 2 of data1_gettagbyname. Expected _p_data1_tagset");
            }
        }
        if (!SvOK((SV*) ST(2))) arg3 = 0;
        else arg3 = (char *) SvPV(ST(2), PL_na);
        result = (data1_tag *)data1_gettagbyname(arg1,arg2,(char const *)arg3);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_data1_tag,0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_free_tree) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        data1_node *arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: data1_free_tree(dh,t);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_free_tree. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_data1_node,0) < 0) {
                SWIG_croak("Type error in argument 2 of data1_free_tree. Expected _p_data1_node");
            }
        }
        data1_free_tree(arg1,arg2);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_nodetobuf) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        data1_node *arg2 ;
        int arg3 ;
        int *arg4 ;
        char *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 4) || (items > 4)) {
            SWIG_croak("Usage: data1_nodetobuf(dh,n,select,len);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_nodetobuf. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_data1_node,0) < 0) {
                SWIG_croak("Type error in argument 2 of data1_nodetobuf. Expected _p_data1_node");
            }
        }
        arg3 = (int) SvIV(ST(2));
        {
            if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_int,0) < 0) {
                SWIG_croak("Type error in argument 4 of data1_nodetobuf. Expected _p_int");
            }
        }
        result = (char *)data1_nodetobuf(arg1,arg2,arg3,arg4);
        
        ST(argvi) = sv_newmortal();
        if (result) {
            sv_setpv((SV*)ST(argvi++), (char *) result);
        }else {
            sv_setsv((SV*)ST(argvi++), &PL_sv_undef);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_mk_tag_data_wd) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        data1_node *arg2 ;
        char *arg3 ;
        NMEM arg4 ;
        data1_node *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 4) || (items > 4)) {
            SWIG_croak("Usage: data1_mk_tag_data_wd(dh,at,tagname,m);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_mk_tag_data_wd. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_data1_node,0) < 0) {
                SWIG_croak("Type error in argument 2 of data1_mk_tag_data_wd. Expected _p_data1_node");
            }
        }
        if (!SvOK((SV*) ST(2))) arg3 = 0;
        else arg3 = (char *) SvPV(ST(2), PL_na);
        {
            NMEM * argp;
            if (SWIG_ConvertPtr(ST(3),(void **) &argp, SWIGTYPE_p_NMEM,0) < 0) {
                SWIG_croak("Type error in argument 4 of data1_mk_tag_data_wd. Expected _p_NMEM");
            }
            arg4 = *argp;
        }
        result = (data1_node *)data1_mk_tag_data_wd(arg1,arg2,(char const *)arg3,arg4);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_data1_node,0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_mk_tag_data) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        data1_node *arg2 ;
        char *arg3 ;
        NMEM arg4 ;
        data1_node *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 4) || (items > 4)) {
            SWIG_croak("Usage: data1_mk_tag_data(dh,at,tagname,m);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_mk_tag_data. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_data1_node,0) < 0) {
                SWIG_croak("Type error in argument 2 of data1_mk_tag_data. Expected _p_data1_node");
            }
        }
        if (!SvOK((SV*) ST(2))) arg3 = 0;
        else arg3 = (char *) SvPV(ST(2), PL_na);
        {
            NMEM * argp;
            if (SWIG_ConvertPtr(ST(3),(void **) &argp, SWIGTYPE_p_NMEM,0) < 0) {
                SWIG_croak("Type error in argument 4 of data1_mk_tag_data. Expected _p_NMEM");
            }
            arg4 = *argp;
        }
        result = (data1_node *)data1_mk_tag_data(arg1,arg2,(char const *)arg3,arg4);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_data1_node,0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_maptype) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        char *arg2 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: data1_maptype(dh,t);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_maptype. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        result = (int)data1_maptype(arg1,arg2);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_read_varset) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        char *arg2 ;
        data1_varset *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: data1_read_varset(dh,file);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_read_varset. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        result = (data1_varset *)data1_read_varset(arg1,(char const *)arg2);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_data1_varset,0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_getvartypebyct) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        data1_varset *arg2 ;
        char *arg3 ;
        char *arg4 ;
        data1_vartype *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 4) || (items > 4)) {
            SWIG_croak("Usage: data1_getvartypebyct(dh,set,zclass,type);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_getvartypebyct. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_data1_varset,0) < 0) {
                SWIG_croak("Type error in argument 2 of data1_getvartypebyct. Expected _p_data1_varset");
            }
        }
        if (!SvOK((SV*) ST(2))) arg3 = 0;
        else arg3 = (char *) SvPV(ST(2), PL_na);
        if (!SvOK((SV*) ST(3))) arg4 = 0;
        else arg4 = (char *) SvPV(ST(3), PL_na);
        result = (data1_vartype *)data1_getvartypebyct(arg1,arg2,arg3,arg4);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_data1_vartype,0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_read_espec1) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        char *arg2 ;
        Z_Espec1 *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: data1_read_espec1(dh,file);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_read_espec1. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        result = (Z_Espec1 *)data1_read_espec1(arg1,(char const *)arg2);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Z_Espec1,0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_doespec1) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        data1_node *arg2 ;
        Z_Espec1 *arg3 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: data1_doespec1(dh,n,e);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_doespec1. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_data1_node,0) < 0) {
                SWIG_croak("Type error in argument 2 of data1_doespec1. Expected _p_data1_node");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_Z_Espec1,0) < 0) {
                SWIG_croak("Type error in argument 3 of data1_doespec1. Expected _p_Z_Espec1");
            }
        }
        result = (int)data1_doespec1(arg1,arg2,arg3);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_getesetbyname) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        data1_absyn *arg2 ;
        char *arg3 ;
        data1_esetname *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: data1_getesetbyname(dh,a,name);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_getesetbyname. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_data1_absyn,0) < 0) {
                SWIG_croak("Type error in argument 2 of data1_getesetbyname. Expected _p_data1_absyn");
            }
        }
        if (!SvOK((SV*) ST(2))) arg3 = 0;
        else arg3 = (char *) SvPV(ST(2), PL_na);
        result = (data1_esetname *)data1_getesetbyname(arg1,arg2,(char const *)arg3);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_data1_esetname,0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_getelementbyname) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        data1_absyn *arg2 ;
        char *arg3 ;
        data1_element *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: data1_getelementbyname(dh,absyn,name);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_getelementbyname. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_data1_absyn,0) < 0) {
                SWIG_croak("Type error in argument 2 of data1_getelementbyname. Expected _p_data1_absyn");
            }
        }
        if (!SvOK((SV*) ST(2))) arg3 = 0;
        else arg3 = (char *) SvPV(ST(2), PL_na);
        result = (data1_element *)data1_getelementbyname(arg1,arg2,(char const *)arg3);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_data1_element,0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_mk_node2) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        NMEM arg2 ;
        int arg3 ;
        data1_node *arg4 ;
        data1_node *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 4) || (items > 4)) {
            SWIG_croak("Usage: data1_mk_node2(dh,m,type,parent);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_mk_node2. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        {
            NMEM * argp;
            if (SWIG_ConvertPtr(ST(1),(void **) &argp, SWIGTYPE_p_NMEM,0) < 0) {
                SWIG_croak("Type error in argument 2 of data1_mk_node2. Expected _p_NMEM");
            }
            arg2 = *argp;
        }
        arg3 = (int) SvIV(ST(2));
        {
            if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_data1_node,0) < 0) {
                SWIG_croak("Type error in argument 4 of data1_mk_node2. Expected _p_data1_node");
            }
        }
        result = (data1_node *)data1_mk_node2(arg1,arg2,arg3,arg4);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_data1_node,0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_mk_tag) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        NMEM arg2 ;
        char *arg3 ;
        char **arg4 ;
        data1_node *arg5 ;
        data1_node *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 5) || (items > 5)) {
            SWIG_croak("Usage: data1_mk_tag(dh,nmem,tag,attr,at);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_mk_tag. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        {
            NMEM * argp;
            if (SWIG_ConvertPtr(ST(1),(void **) &argp, SWIGTYPE_p_NMEM,0) < 0) {
                SWIG_croak("Type error in argument 2 of data1_mk_tag. Expected _p_NMEM");
            }
            arg2 = *argp;
        }
        if (!SvOK((SV*) ST(2))) arg3 = 0;
        else arg3 = (char *) SvPV(ST(2), PL_na);
        {
            AV *tempav;
            I32 len;
            int i;
            SV  **tv;
            STRLEN na;
            if (!SvROK(ST(3)))
            croak("Argument 4 is not a reference.");
            if (SvTYPE(SvRV(ST(3))) != SVt_PVAV)
            croak("Argument 4 is not an array.");
            tempav = (AV*)SvRV(ST(3));
            len = av_len(tempav);
            arg4 = (char **) malloc((len+2)*sizeof(char *));
            for (i = 0; i <= len; i++) {
                tv = av_fetch(tempav, i, 0);	
                arg4[i] = (char *) SvPV(*tv,na);
            }
            arg4[i] = NULL;
        }
        {
            if (SWIG_ConvertPtr(ST(4), (void **) &arg5, SWIGTYPE_p_data1_node,0) < 0) {
                SWIG_croak("Type error in argument 5 of data1_mk_tag. Expected _p_data1_node");
            }
        }
        result = (data1_node *)data1_mk_tag(arg1,arg2,(char const *)arg3,(char const **)arg4,arg5);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_data1_node,0);
        {
            free(arg4);
        }
        XSRETURN(argvi);
        fail:
        {
            free(arg4);
        }
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_mk_tag_n) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        NMEM arg2 ;
        char *arg3 ;
        size_t arg4 ;
        char **arg5 ;
        data1_node *arg6 ;
        data1_node *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 6) || (items > 6)) {
            SWIG_croak("Usage: data1_mk_tag_n(dh,nmem,tag,len,attr,at);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_mk_tag_n. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        {
            NMEM * argp;
            if (SWIG_ConvertPtr(ST(1),(void **) &argp, SWIGTYPE_p_NMEM,0) < 0) {
                SWIG_croak("Type error in argument 2 of data1_mk_tag_n. Expected _p_NMEM");
            }
            arg2 = *argp;
        }
        if (!SvOK((SV*) ST(2))) arg3 = 0;
        else arg3 = (char *) SvPV(ST(2), PL_na);
        arg4 = (size_t) SvUV(ST(3));
        {
            AV *tempav;
            I32 len;
            int i;
            SV  **tv;
            STRLEN na;
            if (!SvROK(ST(4)))
            croak("Argument 5 is not a reference.");
            if (SvTYPE(SvRV(ST(4))) != SVt_PVAV)
            croak("Argument 5 is not an array.");
            tempav = (AV*)SvRV(ST(4));
            len = av_len(tempav);
            arg5 = (char **) malloc((len+2)*sizeof(char *));
            for (i = 0; i <= len; i++) {
                tv = av_fetch(tempav, i, 0);	
                arg5[i] = (char *) SvPV(*tv,na);
            }
            arg5[i] = NULL;
        }
        {
            if (SWIG_ConvertPtr(ST(5), (void **) &arg6, SWIGTYPE_p_data1_node,0) < 0) {
                SWIG_croak("Type error in argument 6 of data1_mk_tag_n. Expected _p_data1_node");
            }
        }
        result = (data1_node *)data1_mk_tag_n(arg1,arg2,(char const *)arg3,arg4,(char const **)arg5,arg6);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_data1_node,0);
        {
            free(arg5);
        }
        XSRETURN(argvi);
        fail:
        {
            free(arg5);
        }
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_tag_add_attr) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        NMEM arg2 ;
        data1_node *arg3 ;
        char **arg4 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 4) || (items > 4)) {
            SWIG_croak("Usage: data1_tag_add_attr(dh,nmem,res,attr);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_tag_add_attr. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        {
            NMEM * argp;
            if (SWIG_ConvertPtr(ST(1),(void **) &argp, SWIGTYPE_p_NMEM,0) < 0) {
                SWIG_croak("Type error in argument 2 of data1_tag_add_attr. Expected _p_NMEM");
            }
            arg2 = *argp;
        }
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_data1_node,0) < 0) {
                SWIG_croak("Type error in argument 3 of data1_tag_add_attr. Expected _p_data1_node");
            }
        }
        {
            AV *tempav;
            I32 len;
            int i;
            SV  **tv;
            STRLEN na;
            if (!SvROK(ST(3)))
            croak("Argument 4 is not a reference.");
            if (SvTYPE(SvRV(ST(3))) != SVt_PVAV)
            croak("Argument 4 is not an array.");
            tempav = (AV*)SvRV(ST(3));
            len = av_len(tempav);
            arg4 = (char **) malloc((len+2)*sizeof(char *));
            for (i = 0; i <= len; i++) {
                tv = av_fetch(tempav, i, 0);	
                arg4[i] = (char *) SvPV(*tv,na);
            }
            arg4[i] = NULL;
        }
        data1_tag_add_attr(arg1,arg2,arg3,(char const **)arg4);
        
        
        {
            free(arg4);
        }
        XSRETURN(argvi);
        fail:
        {
            free(arg4);
        }
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_mk_text_n) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        NMEM arg2 ;
        char *arg3 ;
        size_t arg4 ;
        data1_node *arg5 ;
        data1_node *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 5) || (items > 5)) {
            SWIG_croak("Usage: data1_mk_text_n(dh,mem,buf,len,parent);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_mk_text_n. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        {
            NMEM * argp;
            if (SWIG_ConvertPtr(ST(1),(void **) &argp, SWIGTYPE_p_NMEM,0) < 0) {
                SWIG_croak("Type error in argument 2 of data1_mk_text_n. Expected _p_NMEM");
            }
            arg2 = *argp;
        }
        if (!SvOK((SV*) ST(2))) arg3 = 0;
        else arg3 = (char *) SvPV(ST(2), PL_na);
        arg4 = (size_t) SvUV(ST(3));
        {
            if (SWIG_ConvertPtr(ST(4), (void **) &arg5, SWIGTYPE_p_data1_node,0) < 0) {
                SWIG_croak("Type error in argument 5 of data1_mk_text_n. Expected _p_data1_node");
            }
        }
        result = (data1_node *)data1_mk_text_n(arg1,arg2,(char const *)arg3,arg4,arg5);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_data1_node,0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_mk_text_nf) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        NMEM arg2 ;
        char *arg3 ;
        size_t arg4 ;
        data1_node *arg5 ;
        data1_node *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 5) || (items > 5)) {
            SWIG_croak("Usage: data1_mk_text_nf(dh,mem,buf,len,parent);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_mk_text_nf. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        {
            NMEM * argp;
            if (SWIG_ConvertPtr(ST(1),(void **) &argp, SWIGTYPE_p_NMEM,0) < 0) {
                SWIG_croak("Type error in argument 2 of data1_mk_text_nf. Expected _p_NMEM");
            }
            arg2 = *argp;
        }
        if (!SvOK((SV*) ST(2))) arg3 = 0;
        else arg3 = (char *) SvPV(ST(2), PL_na);
        arg4 = (size_t) SvUV(ST(3));
        {
            if (SWIG_ConvertPtr(ST(4), (void **) &arg5, SWIGTYPE_p_data1_node,0) < 0) {
                SWIG_croak("Type error in argument 5 of data1_mk_text_nf. Expected _p_data1_node");
            }
        }
        result = (data1_node *)data1_mk_text_nf(arg1,arg2,(char const *)arg3,arg4,arg5);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_data1_node,0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_mk_text) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        NMEM arg2 ;
        char *arg3 ;
        data1_node *arg4 ;
        data1_node *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 4) || (items > 4)) {
            SWIG_croak("Usage: data1_mk_text(dh,mem,buf,parent);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_mk_text. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        {
            NMEM * argp;
            if (SWIG_ConvertPtr(ST(1),(void **) &argp, SWIGTYPE_p_NMEM,0) < 0) {
                SWIG_croak("Type error in argument 2 of data1_mk_text. Expected _p_NMEM");
            }
            arg2 = *argp;
        }
        if (!SvOK((SV*) ST(2))) arg3 = 0;
        else arg3 = (char *) SvPV(ST(2), PL_na);
        {
            if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_data1_node,0) < 0) {
                SWIG_croak("Type error in argument 4 of data1_mk_text. Expected _p_data1_node");
            }
        }
        result = (data1_node *)data1_mk_text(arg1,arg2,(char const *)arg3,arg4);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_data1_node,0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_mk_comment_n) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        NMEM arg2 ;
        char *arg3 ;
        size_t arg4 ;
        data1_node *arg5 ;
        data1_node *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 5) || (items > 5)) {
            SWIG_croak("Usage: data1_mk_comment_n(dh,mem,buf,len,parent);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_mk_comment_n. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        {
            NMEM * argp;
            if (SWIG_ConvertPtr(ST(1),(void **) &argp, SWIGTYPE_p_NMEM,0) < 0) {
                SWIG_croak("Type error in argument 2 of data1_mk_comment_n. Expected _p_NMEM");
            }
            arg2 = *argp;
        }
        if (!SvOK((SV*) ST(2))) arg3 = 0;
        else arg3 = (char *) SvPV(ST(2), PL_na);
        arg4 = (size_t) SvUV(ST(3));
        {
            if (SWIG_ConvertPtr(ST(4), (void **) &arg5, SWIGTYPE_p_data1_node,0) < 0) {
                SWIG_croak("Type error in argument 5 of data1_mk_comment_n. Expected _p_data1_node");
            }
        }
        result = (data1_node *)data1_mk_comment_n(arg1,arg2,(char const *)arg3,arg4,arg5);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_data1_node,0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_mk_comment) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        NMEM arg2 ;
        char *arg3 ;
        data1_node *arg4 ;
        data1_node *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 4) || (items > 4)) {
            SWIG_croak("Usage: data1_mk_comment(dh,mem,buf,parent);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_mk_comment. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        {
            NMEM * argp;
            if (SWIG_ConvertPtr(ST(1),(void **) &argp, SWIGTYPE_p_NMEM,0) < 0) {
                SWIG_croak("Type error in argument 2 of data1_mk_comment. Expected _p_NMEM");
            }
            arg2 = *argp;
        }
        if (!SvOK((SV*) ST(2))) arg3 = 0;
        else arg3 = (char *) SvPV(ST(2), PL_na);
        {
            if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_data1_node,0) < 0) {
                SWIG_croak("Type error in argument 4 of data1_mk_comment. Expected _p_data1_node");
            }
        }
        result = (data1_node *)data1_mk_comment(arg1,arg2,(char const *)arg3,arg4);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_data1_node,0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_mk_preprocess) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        NMEM arg2 ;
        char *arg3 ;
        char **arg4 ;
        data1_node *arg5 ;
        data1_node *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 5) || (items > 5)) {
            SWIG_croak("Usage: data1_mk_preprocess(dh,nmem,target,attr,at);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_mk_preprocess. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        {
            NMEM * argp;
            if (SWIG_ConvertPtr(ST(1),(void **) &argp, SWIGTYPE_p_NMEM,0) < 0) {
                SWIG_croak("Type error in argument 2 of data1_mk_preprocess. Expected _p_NMEM");
            }
            arg2 = *argp;
        }
        if (!SvOK((SV*) ST(2))) arg3 = 0;
        else arg3 = (char *) SvPV(ST(2), PL_na);
        {
            AV *tempav;
            I32 len;
            int i;
            SV  **tv;
            STRLEN na;
            if (!SvROK(ST(3)))
            croak("Argument 4 is not a reference.");
            if (SvTYPE(SvRV(ST(3))) != SVt_PVAV)
            croak("Argument 4 is not an array.");
            tempav = (AV*)SvRV(ST(3));
            len = av_len(tempav);
            arg4 = (char **) malloc((len+2)*sizeof(char *));
            for (i = 0; i <= len; i++) {
                tv = av_fetch(tempav, i, 0);	
                arg4[i] = (char *) SvPV(*tv,na);
            }
            arg4[i] = NULL;
        }
        {
            if (SWIG_ConvertPtr(ST(4), (void **) &arg5, SWIGTYPE_p_data1_node,0) < 0) {
                SWIG_croak("Type error in argument 5 of data1_mk_preprocess. Expected _p_data1_node");
            }
        }
        result = (data1_node *)data1_mk_preprocess(arg1,arg2,(char const *)arg3,(char const **)arg4,arg5);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_data1_node,0);
        {
            free(arg4);
        }
        XSRETURN(argvi);
        fail:
        {
            free(arg4);
        }
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_mk_root) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        NMEM arg2 ;
        char *arg3 ;
        data1_node *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: data1_mk_root(dh,nmem,name);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_mk_root. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        {
            NMEM * argp;
            if (SWIG_ConvertPtr(ST(1),(void **) &argp, SWIGTYPE_p_NMEM,0) < 0) {
                SWIG_croak("Type error in argument 2 of data1_mk_root. Expected _p_NMEM");
            }
            arg2 = *argp;
        }
        if (!SvOK((SV*) ST(2))) arg3 = 0;
        else arg3 = (char *) SvPV(ST(2), PL_na);
        result = (data1_node *)data1_mk_root(arg1,arg2,(char const *)arg3);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_data1_node,0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_set_root) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        data1_node *arg2 ;
        NMEM arg3 ;
        char *arg4 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 4) || (items > 4)) {
            SWIG_croak("Usage: data1_set_root(dh,res,nmem,name);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_set_root. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_data1_node,0) < 0) {
                SWIG_croak("Type error in argument 2 of data1_set_root. Expected _p_data1_node");
            }
        }
        {
            NMEM * argp;
            if (SWIG_ConvertPtr(ST(2),(void **) &argp, SWIGTYPE_p_NMEM,0) < 0) {
                SWIG_croak("Type error in argument 3 of data1_set_root. Expected _p_NMEM");
            }
            arg3 = *argp;
        }
        if (!SvOK((SV*) ST(3))) arg4 = 0;
        else arg4 = (char *) SvPV(ST(3), PL_na);
        data1_set_root(arg1,arg2,arg3,(char const *)arg4);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_mk_tag_data_int) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        data1_node *arg2 ;
        char *arg3 ;
        int arg4 ;
        NMEM arg5 ;
        data1_node *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 5) || (items > 5)) {
            SWIG_croak("Usage: data1_mk_tag_data_int(dh,at,tag,num,nmem);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_mk_tag_data_int. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_data1_node,0) < 0) {
                SWIG_croak("Type error in argument 2 of data1_mk_tag_data_int. Expected _p_data1_node");
            }
        }
        if (!SvOK((SV*) ST(2))) arg3 = 0;
        else arg3 = (char *) SvPV(ST(2), PL_na);
        arg4 = (int) SvIV(ST(3));
        {
            NMEM * argp;
            if (SWIG_ConvertPtr(ST(4),(void **) &argp, SWIGTYPE_p_NMEM,0) < 0) {
                SWIG_croak("Type error in argument 5 of data1_mk_tag_data_int. Expected _p_NMEM");
            }
            arg5 = *argp;
        }
        result = (data1_node *)data1_mk_tag_data_int(arg1,arg2,(char const *)arg3,arg4,arg5);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_data1_node,0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_mk_tag_data_oid) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        data1_node *arg2 ;
        char *arg3 ;
        Odr_oid *arg4 ;
        NMEM arg5 ;
        data1_node *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 5) || (items > 5)) {
            SWIG_croak("Usage: data1_mk_tag_data_oid(dh,at,tag,oid,nmem);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_mk_tag_data_oid. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_data1_node,0) < 0) {
                SWIG_croak("Type error in argument 2 of data1_mk_tag_data_oid. Expected _p_data1_node");
            }
        }
        if (!SvOK((SV*) ST(2))) arg3 = 0;
        else arg3 = (char *) SvPV(ST(2), PL_na);
        {
            if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_Odr_oid,0) < 0) {
                SWIG_croak("Type error in argument 4 of data1_mk_tag_data_oid. Expected _p_Odr_oid");
            }
        }
        {
            NMEM * argp;
            if (SWIG_ConvertPtr(ST(4),(void **) &argp, SWIGTYPE_p_NMEM,0) < 0) {
                SWIG_croak("Type error in argument 5 of data1_mk_tag_data_oid. Expected _p_NMEM");
            }
            arg5 = *argp;
        }
        result = (data1_node *)data1_mk_tag_data_oid(arg1,arg2,(char const *)arg3,arg4,arg5);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_data1_node,0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_mk_tag_data_text) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        data1_node *arg2 ;
        char *arg3 ;
        char *arg4 ;
        NMEM arg5 ;
        data1_node *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 5) || (items > 5)) {
            SWIG_croak("Usage: data1_mk_tag_data_text(dh,at,tag,str,nmem);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_mk_tag_data_text. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_data1_node,0) < 0) {
                SWIG_croak("Type error in argument 2 of data1_mk_tag_data_text. Expected _p_data1_node");
            }
        }
        if (!SvOK((SV*) ST(2))) arg3 = 0;
        else arg3 = (char *) SvPV(ST(2), PL_na);
        if (!SvOK((SV*) ST(3))) arg4 = 0;
        else arg4 = (char *) SvPV(ST(3), PL_na);
        {
            NMEM * argp;
            if (SWIG_ConvertPtr(ST(4),(void **) &argp, SWIGTYPE_p_NMEM,0) < 0) {
                SWIG_croak("Type error in argument 5 of data1_mk_tag_data_text. Expected _p_NMEM");
            }
            arg5 = *argp;
        }
        result = (data1_node *)data1_mk_tag_data_text(arg1,arg2,(char const *)arg3,(char const *)arg4,arg5);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_data1_node,0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_mk_tag_data_text_uni) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        data1_node *arg2 ;
        char *arg3 ;
        char *arg4 ;
        NMEM arg5 ;
        data1_node *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 5) || (items > 5)) {
            SWIG_croak("Usage: data1_mk_tag_data_text_uni(dh,at,tag,str,nmem);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_mk_tag_data_text_uni. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_data1_node,0) < 0) {
                SWIG_croak("Type error in argument 2 of data1_mk_tag_data_text_uni. Expected _p_data1_node");
            }
        }
        if (!SvOK((SV*) ST(2))) arg3 = 0;
        else arg3 = (char *) SvPV(ST(2), PL_na);
        if (!SvOK((SV*) ST(3))) arg4 = 0;
        else arg4 = (char *) SvPV(ST(3), PL_na);
        {
            NMEM * argp;
            if (SWIG_ConvertPtr(ST(4),(void **) &argp, SWIGTYPE_p_NMEM,0) < 0) {
                SWIG_croak("Type error in argument 5 of data1_mk_tag_data_text_uni. Expected _p_NMEM");
            }
            arg5 = *argp;
        }
        result = (data1_node *)data1_mk_tag_data_text_uni(arg1,arg2,(char const *)arg3,(char const *)arg4,arg5);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_data1_node,0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_get_absyn) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        char *arg2 ;
        data1_absyn *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: data1_get_absyn(dh,name);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_get_absyn. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        result = (data1_absyn *)data1_get_absyn(arg1,(char const *)arg2);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_data1_absyn,0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_search_tag) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        data1_node *arg2 ;
        char *arg3 ;
        data1_node *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: data1_search_tag(dh,n,tag);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_search_tag. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_data1_node,0) < 0) {
                SWIG_croak("Type error in argument 2 of data1_search_tag. Expected _p_data1_node");
            }
        }
        if (!SvOK((SV*) ST(2))) arg3 = 0;
        else arg3 = (char *) SvPV(ST(2), PL_na);
        result = (data1_node *)data1_search_tag(arg1,arg2,(char const *)arg3);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_data1_node,0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_mk_tag_uni) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        NMEM arg2 ;
        char *arg3 ;
        data1_node *arg4 ;
        data1_node *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 4) || (items > 4)) {
            SWIG_croak("Usage: data1_mk_tag_uni(dh,nmem,tag,at);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_mk_tag_uni. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        {
            NMEM * argp;
            if (SWIG_ConvertPtr(ST(1),(void **) &argp, SWIGTYPE_p_NMEM,0) < 0) {
                SWIG_croak("Type error in argument 2 of data1_mk_tag_uni. Expected _p_NMEM");
            }
            arg2 = *argp;
        }
        if (!SvOK((SV*) ST(2))) arg3 = 0;
        else arg3 = (char *) SvPV(ST(2), PL_na);
        {
            if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_data1_node,0) < 0) {
                SWIG_croak("Type error in argument 4 of data1_mk_tag_uni. Expected _p_data1_node");
            }
        }
        result = (data1_node *)data1_mk_tag_uni(arg1,arg2,(char const *)arg3,arg4);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_data1_node,0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_get_attset) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        char *arg2 ;
        data1_attset *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: data1_get_attset(dh,name);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_get_attset. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        result = (data1_attset *)data1_get_attset(arg1,(char const *)arg2);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_data1_attset,0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_read_maptab) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        char *arg2 ;
        data1_maptab *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: data1_read_maptab(dh,file);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_read_maptab. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        result = (data1_maptab *)data1_read_maptab(arg1,(char const *)arg2);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_data1_maptab,0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_map_record) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        data1_node *arg2 ;
        data1_maptab *arg3 ;
        NMEM arg4 ;
        data1_node *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 4) || (items > 4)) {
            SWIG_croak("Usage: data1_map_record(dh,n,map,m);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_map_record. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_data1_node,0) < 0) {
                SWIG_croak("Type error in argument 2 of data1_map_record. Expected _p_data1_node");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_data1_maptab,0) < 0) {
                SWIG_croak("Type error in argument 3 of data1_map_record. Expected _p_data1_maptab");
            }
        }
        {
            NMEM * argp;
            if (SWIG_ConvertPtr(ST(3),(void **) &argp, SWIGTYPE_p_NMEM,0) < 0) {
                SWIG_croak("Type error in argument 4 of data1_map_record. Expected _p_NMEM");
            }
            arg4 = *argp;
        }
        result = (data1_node *)data1_map_record(arg1,arg2,arg3,arg4);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_data1_node,0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_read_marctab) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        char *arg2 ;
        data1_marctab *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: data1_read_marctab(dh,file);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_read_marctab. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        result = (data1_marctab *)data1_read_marctab(arg1,(char const *)arg2);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_data1_marctab,0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_nodetomarc) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        data1_marctab *arg2 ;
        data1_node *arg3 ;
        int arg4 ;
        int *arg5 ;
        char *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 5) || (items > 5)) {
            SWIG_croak("Usage: data1_nodetomarc(dh,p,n,selected,len);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_nodetomarc. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_data1_marctab,0) < 0) {
                SWIG_croak("Type error in argument 2 of data1_nodetomarc. Expected _p_data1_marctab");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_data1_node,0) < 0) {
                SWIG_croak("Type error in argument 3 of data1_nodetomarc. Expected _p_data1_node");
            }
        }
        arg4 = (int) SvIV(ST(3));
        {
            if (SWIG_ConvertPtr(ST(4), (void **) &arg5, SWIGTYPE_p_int,0) < 0) {
                SWIG_croak("Type error in argument 5 of data1_nodetomarc. Expected _p_int");
            }
        }
        result = (char *)data1_nodetomarc(arg1,arg2,arg3,arg4,arg5);
        
        ST(argvi) = sv_newmortal();
        if (result) {
            sv_setpv((SV*)ST(argvi++), (char *) result);
        }else {
            sv_setsv((SV*)ST(argvi++), &PL_sv_undef);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_nodetoidsgml) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        data1_node *arg2 ;
        int arg3 ;
        int *arg4 ;
        char *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 4) || (items > 4)) {
            SWIG_croak("Usage: data1_nodetoidsgml(dh,n,select,len);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_nodetoidsgml. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_data1_node,0) < 0) {
                SWIG_croak("Type error in argument 2 of data1_nodetoidsgml. Expected _p_data1_node");
            }
        }
        arg3 = (int) SvIV(ST(2));
        {
            if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_int,0) < 0) {
                SWIG_croak("Type error in argument 4 of data1_nodetoidsgml. Expected _p_int");
            }
        }
        result = (char *)data1_nodetoidsgml(arg1,arg2,arg3,arg4);
        
        ST(argvi) = sv_newmortal();
        if (result) {
            sv_setpv((SV*)ST(argvi++), (char *) result);
        }else {
            sv_setsv((SV*)ST(argvi++), &PL_sv_undef);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_nodetoexplain) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        data1_node *arg2 ;
        int arg3 ;
        ODR arg4 ;
        Z_ExplainRecord *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 4) || (items > 4)) {
            SWIG_croak("Usage: data1_nodetoexplain(dh,n,select,o);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_nodetoexplain. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_data1_node,0) < 0) {
                SWIG_croak("Type error in argument 2 of data1_nodetoexplain. Expected _p_data1_node");
            }
        }
        arg3 = (int) SvIV(ST(2));
        {
            ODR * argp;
            if (SWIG_ConvertPtr(ST(3),(void **) &argp, SWIGTYPE_p_ODR,0) < 0) {
                SWIG_croak("Type error in argument 4 of data1_nodetoexplain. Expected _p_ODR");
            }
            arg4 = *argp;
        }
        result = (Z_ExplainRecord *)data1_nodetoexplain(arg1,arg2,arg3,arg4);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Z_ExplainRecord,0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_nodetosummary) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        data1_node *arg2 ;
        int arg3 ;
        ODR arg4 ;
        Z_BriefBib *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 4) || (items > 4)) {
            SWIG_croak("Usage: data1_nodetosummary(dh,n,select,o);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_nodetosummary. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_data1_node,0) < 0) {
                SWIG_croak("Type error in argument 2 of data1_nodetosummary. Expected _p_data1_node");
            }
        }
        arg3 = (int) SvIV(ST(2));
        {
            ODR * argp;
            if (SWIG_ConvertPtr(ST(3),(void **) &argp, SWIGTYPE_p_ODR,0) < 0) {
                SWIG_croak("Type error in argument 4 of data1_nodetosummary. Expected _p_ODR");
            }
            arg4 = *argp;
        }
        result = (Z_BriefBib *)data1_nodetosummary(arg1,arg2,arg3,arg4);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_Z_BriefBib,0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_nodetosoif) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        data1_node *arg2 ;
        int arg3 ;
        int *arg4 ;
        char *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 4) || (items > 4)) {
            SWIG_croak("Usage: data1_nodetosoif(dh,n,select,len);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_nodetosoif. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_data1_node,0) < 0) {
                SWIG_croak("Type error in argument 2 of data1_nodetosoif. Expected _p_data1_node");
            }
        }
        arg3 = (int) SvIV(ST(2));
        {
            if (SWIG_ConvertPtr(ST(3), (void **) &arg4, SWIGTYPE_p_int,0) < 0) {
                SWIG_croak("Type error in argument 4 of data1_nodetosoif. Expected _p_int");
            }
        }
        result = (char *)data1_nodetosoif(arg1,arg2,arg3,arg4);
        
        ST(argvi) = sv_newmortal();
        if (result) {
            sv_setpv((SV*)ST(argvi++), (char *) result);
        }else {
            sv_setsv((SV*)ST(argvi++), &PL_sv_undef);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_get_wrbuf) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        WRBUF result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: data1_get_wrbuf(dp);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_get_wrbuf. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        result = data1_get_wrbuf(arg1);
        
        {
            WRBUF * resultobj = (WRBUF *) malloc(sizeof(WRBUF));
            memmove(resultobj, &result, sizeof(WRBUF));
            ST(argvi) = sv_newmortal();
            SWIG_MakePtr(ST(argvi++), (void *) resultobj, SWIGTYPE_p_WRBUF,0);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_get_read_buf) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        int **arg2 ;
        char **result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: data1_get_read_buf(dp,lenp);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_get_read_buf. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_p_int,0) < 0) {
                SWIG_croak("Type error in argument 2 of data1_get_read_buf. Expected _p_p_int");
            }
        }
        result = (char **)data1_get_read_buf(arg1,arg2);
        
        {
            AV *myav;
            SV **svs;
            int i = 0,len = 0;
            /* Figure out how many elements we have */
            while (result[len])
            len++;
            svs = (SV **) malloc(len*sizeof(SV *));
            for (i = 0; i < len ; i++) {
                svs[i] = sv_newmortal();
                sv_setpv((SV*)svs[i],result[i]);
            };
            myav =  av_make(len,svs);
            free(svs);
            ST(argvi) = newRV((SV*)myav);
            sv_2mortal(ST(argvi));
            argvi++;
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_get_map_buf) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        int **arg2 ;
        char **result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: data1_get_map_buf(dp,lenp);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_get_map_buf. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_p_int,0) < 0) {
                SWIG_croak("Type error in argument 2 of data1_get_map_buf. Expected _p_p_int");
            }
        }
        result = (char **)data1_get_map_buf(arg1,arg2);
        
        {
            AV *myav;
            SV **svs;
            int i = 0,len = 0;
            /* Figure out how many elements we have */
            while (result[len])
            len++;
            svs = (SV **) malloc(len*sizeof(SV *));
            for (i = 0; i < len ; i++) {
                svs[i] = sv_newmortal();
                sv_setpv((SV*)svs[i],result[i]);
            };
            myav =  av_make(len,svs);
            free(svs);
            ST(argvi) = newRV((SV*)myav);
            sv_2mortal(ST(argvi));
            argvi++;
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_absyn_cache_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        data1_absyn_cache *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: data1_absyn_cache_get(dh);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_absyn_cache_get. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        result = (data1_absyn_cache *)data1_absyn_cache_get(arg1);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_data1_absyn_cache,0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_attset_cache_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        data1_attset_cache *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: data1_attset_cache_get(dh);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_attset_cache_get. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        result = (data1_attset_cache *)data1_attset_cache_get(arg1);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_data1_attset_cache,0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_nmem_get) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        NMEM result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: data1_nmem_get(dh);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_nmem_get. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        result = data1_nmem_get(arg1);
        
        {
            NMEM * resultobj = (NMEM *) malloc(sizeof(NMEM));
            memmove(resultobj, &result, sizeof(NMEM));
            ST(argvi) = sv_newmortal();
            SWIG_MakePtr(ST(argvi++), (void *) resultobj, SWIGTYPE_p_NMEM,0);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_pr_tree) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        data1_node *arg2 ;
        FILE *arg3 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: data1_pr_tree(dh,n,out);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_pr_tree. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_data1_node,0) < 0) {
                SWIG_croak("Type error in argument 2 of data1_pr_tree. Expected _p_data1_node");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_FILE,0) < 0) {
                SWIG_croak("Type error in argument 3 of data1_pr_tree. Expected _p_FILE");
            }
        }
        data1_pr_tree(arg1,arg2,arg3);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_print_tree) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        data1_node *arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: data1_print_tree(dh,n);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_print_tree. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_data1_node,0) < 0) {
                SWIG_croak("Type error in argument 2 of data1_print_tree. Expected _p_data1_node");
            }
        }
        data1_print_tree(arg1,arg2);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_insert_string) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        data1_node *arg2 ;
        NMEM arg3 ;
        char *arg4 ;
        char *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 4) || (items > 4)) {
            SWIG_croak("Usage: data1_insert_string(dh,res,m,str);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_insert_string. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_data1_node,0) < 0) {
                SWIG_croak("Type error in argument 2 of data1_insert_string. Expected _p_data1_node");
            }
        }
        {
            NMEM * argp;
            if (SWIG_ConvertPtr(ST(2),(void **) &argp, SWIGTYPE_p_NMEM,0) < 0) {
                SWIG_croak("Type error in argument 3 of data1_insert_string. Expected _p_NMEM");
            }
            arg3 = *argp;
        }
        if (!SvOK((SV*) ST(3))) arg4 = 0;
        else arg4 = (char *) SvPV(ST(3), PL_na);
        result = (char *)data1_insert_string(arg1,arg2,arg3,(char const *)arg4);
        
        ST(argvi) = sv_newmortal();
        if (result) {
            sv_setpv((SV*)ST(argvi++), (char *) result);
        }else {
            sv_setsv((SV*)ST(argvi++), &PL_sv_undef);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_insert_string_n) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        data1_node *arg2 ;
        NMEM arg3 ;
        char *arg4 ;
        size_t arg5 ;
        char *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 5) || (items > 5)) {
            SWIG_croak("Usage: data1_insert_string_n(dh,res,m,str,len);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_insert_string_n. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_data1_node,0) < 0) {
                SWIG_croak("Type error in argument 2 of data1_insert_string_n. Expected _p_data1_node");
            }
        }
        {
            NMEM * argp;
            if (SWIG_ConvertPtr(ST(2),(void **) &argp, SWIGTYPE_p_NMEM,0) < 0) {
                SWIG_croak("Type error in argument 3 of data1_insert_string_n. Expected _p_NMEM");
            }
            arg3 = *argp;
        }
        if (!SvOK((SV*) ST(3))) arg4 = 0;
        else arg4 = (char *) SvPV(ST(3), PL_na);
        arg5 = (size_t) SvUV(ST(4));
        result = (char *)data1_insert_string_n(arg1,arg2,arg3,(char const *)arg4,arg5);
        
        ST(argvi) = sv_newmortal();
        if (result) {
            sv_setpv((SV*)ST(argvi++), (char *) result);
        }else {
            sv_setsv((SV*)ST(argvi++), &PL_sv_undef);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_read_sgml) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        NMEM arg2 ;
        char *arg3 ;
        data1_node *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: data1_read_sgml(dh,m,buf);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_read_sgml. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        {
            NMEM * argp;
            if (SWIG_ConvertPtr(ST(1),(void **) &argp, SWIGTYPE_p_NMEM,0) < 0) {
                SWIG_croak("Type error in argument 2 of data1_read_sgml. Expected _p_NMEM");
            }
            arg2 = *argp;
        }
        if (!SvOK((SV*) ST(2))) arg3 = 0;
        else arg3 = (char *) SvPV(ST(2), PL_na);
        result = (data1_node *)data1_read_sgml(arg1,arg2,(char const *)arg3);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_data1_node,0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_absyn_trav) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        void *arg2 ;
        void (*arg3)(data1_handle,void *,data1_absyn *) ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: data1_absyn_trav(dh,handle,fh);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_absyn_trav. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, 0,0) < 0) {
                SWIG_croak("Type error in argument 2 of data1_absyn_trav. Expected _p_void");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(2), (void **) &arg3, SWIGTYPE_p_f_data1_handle_p_void_p_data1_absyn__void,0) < 0) {
                SWIG_croak("Type error in argument 3 of data1_absyn_trav. Expected _p_f_data1_handle_p_void_p_data1_absyn__void");
            }
        }
        data1_absyn_trav(arg1,arg2,arg3);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_attset_search_id) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        int arg2 ;
        data1_attset *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: data1_attset_search_id(dh,id);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_attset_search_id. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        arg2 = (int) SvIV(ST(1));
        result = (data1_attset *)data1_attset_search_id(arg1,arg2);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_data1_attset,0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_getNodeValue) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_node *arg1 ;
        char *arg2 ;
        char *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: data1_getNodeValue(node,pTagPath);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_data1_node,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_getNodeValue. Expected _p_data1_node");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        result = (char *)data1_getNodeValue(arg1,arg2);
        
        ST(argvi) = sv_newmortal();
        if (result) {
            sv_setpv((SV*)ST(argvi++), (char *) result);
        }else {
            sv_setsv((SV*)ST(argvi++), &PL_sv_undef);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_LookupNode) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_node *arg1 ;
        char *arg2 ;
        data1_node *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: data1_LookupNode(node,pTagPath);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_data1_node,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_LookupNode. Expected _p_data1_node");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        result = (data1_node *)data1_LookupNode(arg1,arg2);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_data1_node,0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_CountOccurences) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_node *arg1 ;
        char *arg2 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: data1_CountOccurences(node,pTagPath);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_data1_node,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_CountOccurences. Expected _p_data1_node");
            }
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        result = (int)data1_CountOccurences(arg1,arg2);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_path_fopen) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        char *arg2 ;
        char *arg3 ;
        FILE *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 3) || (items > 3)) {
            SWIG_croak("Usage: data1_path_fopen(dh,file,mode);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_path_fopen. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        if (!SvOK((SV*) ST(2))) arg3 = 0;
        else arg3 = (char *) SvPV(ST(2), PL_na);
        result = (FILE *)data1_path_fopen(arg1,(char const *)arg2,(char const *)arg3);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_FILE,0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_set_tabpath) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        char *arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: data1_set_tabpath(dh,path);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_set_tabpath. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        data1_set_tabpath(arg1,(char const *)arg2);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_set_tabroot) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        char *arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: data1_set_tabroot(dp,p);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_set_tabroot. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        if (!SvOK((SV*) ST(1))) arg2 = 0;
        else arg2 = (char *) SvPV(ST(1), PL_na);
        data1_set_tabroot(arg1,(char const *)arg2);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_get_tabpath) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        char *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: data1_get_tabpath(dh);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_get_tabpath. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        result = (char *)data1_get_tabpath(arg1);
        
        ST(argvi) = sv_newmortal();
        if (result) {
            sv_setpv((SV*)ST(argvi++), (char *) result);
        }else {
            sv_setsv((SV*)ST(argvi++), &PL_sv_undef);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_data1_get_tabroot) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        data1_handle arg1 ;
        char *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: data1_get_tabroot(dh);");
        }
        {
            data1_handle * argp;
            if (SWIG_ConvertPtr(ST(0),(void **) &argp, SWIGTYPE_p_data1_handle,0) < 0) {
                SWIG_croak("Type error in argument 1 of data1_get_tabroot. Expected _p_data1_handle");
            }
            arg1 = *argp;
        }
        result = (char *)data1_get_tabroot(arg1);
        
        ST(argvi) = sv_newmortal();
        if (result) {
            sv_setpv((SV*)ST(argvi++), (char *) result);
        }else {
            sv_setsv((SV*)ST(argvi++), &PL_sv_undef);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_grs_perl_readf) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct perl_context *arg1 ;
        size_t arg2 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: grs_perl_readf(context,len);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_perl_context,0) < 0) {
                SWIG_croak("Type error in argument 1 of grs_perl_readf. Expected _p_perl_context");
            }
        }
        arg2 = (size_t) SvUV(ST(1));
        result = (int)grs_perl_readf(arg1,arg2);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_grs_perl_readline) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct perl_context *arg1 ;
        int result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: grs_perl_readline(context);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_perl_context,0) < 0) {
                SWIG_croak("Type error in argument 1 of grs_perl_readline. Expected _p_perl_context");
            }
        }
        result = (int)grs_perl_readline(arg1);
        
        ST(argvi) = sv_newmortal();
        sv_setiv(ST(argvi++), (IV) result);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_grs_perl_getc) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct perl_context *arg1 ;
        char result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: grs_perl_getc(context);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_perl_context,0) < 0) {
                SWIG_croak("Type error in argument 1 of grs_perl_getc. Expected _p_perl_context");
            }
        }
        result = (char)grs_perl_getc(arg1);
        
        ST(argvi) = sv_newmortal();
        sv_setpvn((SV*)ST(argvi++), &result, 1);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_grs_perl_seekf) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct perl_context *arg1 ;
        off_t arg2 ;
        off_t result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: grs_perl_seekf(context,offset);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_perl_context,0) < 0) {
                SWIG_croak("Type error in argument 1 of grs_perl_seekf. Expected _p_perl_context");
            }
        }
        {
            off_t * argp;
            if (SWIG_ConvertPtr(ST(1),(void **) &argp, SWIGTYPE_p_off_t,0) < 0) {
                SWIG_croak("Type error in argument 2 of grs_perl_seekf. Expected _p_off_t");
            }
            arg2 = *argp;
        }
        result = grs_perl_seekf(arg1,arg2);
        
        {
            off_t * resultobj = (off_t *) malloc(sizeof(off_t));
            memmove(resultobj, &result, sizeof(off_t));
            ST(argvi) = sv_newmortal();
            SWIG_MakePtr(ST(argvi++), (void *) resultobj, SWIGTYPE_p_off_t,0);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_grs_perl_tellf) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct perl_context *arg1 ;
        off_t result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: grs_perl_tellf(context);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_perl_context,0) < 0) {
                SWIG_croak("Type error in argument 1 of grs_perl_tellf. Expected _p_perl_context");
            }
        }
        result = grs_perl_tellf(arg1);
        
        {
            off_t * resultobj = (off_t *) malloc(sizeof(off_t));
            memmove(resultobj, &result, sizeof(off_t));
            ST(argvi) = sv_newmortal();
            SWIG_MakePtr(ST(argvi++), (void *) resultobj, SWIGTYPE_p_off_t,0);
        }
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_grs_perl_endf) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct perl_context *arg1 ;
        off_t arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: grs_perl_endf(context,offset);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_perl_context,0) < 0) {
                SWIG_croak("Type error in argument 1 of grs_perl_endf. Expected _p_perl_context");
            }
        }
        {
            off_t * argp;
            if (SWIG_ConvertPtr(ST(1),(void **) &argp, SWIGTYPE_p_off_t,0) < 0) {
                SWIG_croak("Type error in argument 2 of grs_perl_endf. Expected _p_off_t");
            }
            arg2 = *argp;
        }
        grs_perl_endf(arg1,arg2);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_grs_perl_get_dh) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct perl_context *arg1 ;
        data1_handle *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: grs_perl_get_dh(context);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_perl_context,0) < 0) {
                SWIG_croak("Type error in argument 1 of grs_perl_get_dh. Expected _p_perl_context");
            }
        }
        result = (data1_handle *)grs_perl_get_dh(arg1);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_data1_handle,0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_grs_perl_get_mem) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct perl_context *arg1 ;
        NMEM *result;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 1) || (items > 1)) {
            SWIG_croak("Usage: grs_perl_get_mem(context);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_perl_context,0) < 0) {
                SWIG_croak("Type error in argument 1 of grs_perl_get_mem. Expected _p_perl_context");
            }
        }
        result = (NMEM *)grs_perl_get_mem(arg1);
        
        ST(argvi) = sv_newmortal();
        SWIG_MakePtr(ST(argvi++), (void *) result, SWIGTYPE_p_NMEM,0);
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}


XS(_wrap_grs_perl_set_res) {
    char _swigmsg[SWIG_MAX_ERRMSG] = "";
    const char *_swigerr = _swigmsg;
    {
        struct perl_context *arg1 ;
        data1_node *arg2 ;
        int argvi = 0;
        dXSARGS;
        
        if ((items < 2) || (items > 2)) {
            SWIG_croak("Usage: grs_perl_set_res(context,n);");
        }
        {
            if (SWIG_ConvertPtr(ST(0), (void **) &arg1, SWIGTYPE_p_perl_context,0) < 0) {
                SWIG_croak("Type error in argument 1 of grs_perl_set_res. Expected _p_perl_context");
            }
        }
        {
            if (SWIG_ConvertPtr(ST(1), (void **) &arg2, SWIGTYPE_p_data1_node,0) < 0) {
                SWIG_croak("Type error in argument 2 of grs_perl_set_res. Expected _p_data1_node");
            }
        }
        grs_perl_set_res(arg1,arg2);
        
        
        XSRETURN(argvi);
        fail:
        (void) _swigerr;
    }
    croak(_swigerr);
}



/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static swig_type_info _swigt__p_ZebraService[] = {{"_p_ZebraService", 0, "ZebraService *", 0},{"_p_ZebraService"},{0}};
static swig_type_info _swigt__p_cql_transform_t[] = {{"_p_cql_transform_t", 0, "cql_transform_t *", 0},{"_p_cql_transform_t"},{0}};
static swig_type_info _swigt__p_data1_esetname[] = {{"_p_data1_esetname", 0, "data1_esetname *", 0},{"_p_data1_esetname"},{0}};
static swig_type_info _swigt__p_data1_maptab[] = {{"_p_data1_maptab", 0, "data1_maptab *", 0},{"_p_data1_maptab"},{0}};
static swig_type_info _swigt__p_ODR[] = {{"_p_ODR", 0, "ODR *", 0},{"_p_ODR"},{0}};
static swig_type_info _swigt__p_f_p_void__int[] = {{"_p_f_p_void__int", 0, "int (*)(void *)", 0},{"_p_f_p_void__int"},{0}};
static swig_type_info _swigt__p_p_char[] = {{"_p_p_char", 0, "char **", 0},{"_p_p_char"},{0}};
static swig_type_info _swigt__p_data1_absyn[] = {{"_p_data1_absyn", 0, "data1_absyn *", 0},{"_p_data1_absyn"},{0}};
static swig_type_info _swigt__p_ZebraHandle[] = {{"_p_ZebraHandle", 0, "ZebraHandle *", 0},{"_p_ZebraHandle"},{0}};
static swig_type_info _swigt__p_void[] = {{"_p_void", 0, "void *", 0},{"_p_void"},{0}};
static swig_type_info _swigt__p_data1_attset[] = {{"_p_data1_attset", 0, "data1_attset *", 0},{"_p_data1_attset"},{0}};
static swig_type_info _swigt__p_size_t[] = {{"_p_size_t", 0, "size_t *", 0},{"_p_size_t"},{0}};
static swig_type_info _swigt__p_WRBUF[] = {{"_p_WRBUF", 0, "WRBUF *", 0},{"_p_WRBUF"},{0}};
static swig_type_info _swigt__p_f_data1_handle_p_void_p_data1_absyn__void[] = {{"_p_f_data1_handle_p_void_p_data1_absyn__void", 0, "void (*)(data1_handle,void *,data1_absyn *)", 0},{"_p_f_data1_handle_p_void_p_data1_absyn__void"},{0}};
static swig_type_info _swigt__p_Z_Espec1[] = {{"_p_Z_Espec1", 0, "Z_Espec1 *", 0},{"_p_Z_Espec1"},{0}};
static swig_type_info _swigt__p_off_t[] = {{"_p_off_t", 0, "off_t *", 0},{"_p_off_t"},{0}};
static swig_type_info _swigt__p_Odr_oid[] = {{"_p_Odr_oid", 0, "Odr_oid *", 0},{"_p_Odr_oid"},{0}};
static swig_type_info _swigt__p_data1_varset[] = {{"_p_data1_varset", 0, "data1_varset *", 0},{"_p_data1_varset"},{0}};
static swig_type_info _swigt__p_RetrievalRecordBuf[] = {{"_p_RetrievalRecordBuf", 0, "RetrievalRecordBuf *", 0},{"_p_RetrievalRecordBuf"},{0}};
static swig_type_info _swigt__p_perl_context[] = {{"_p_perl_context", 0, "struct perl_context *", 0},{"_p_perl_context"},{0}};
static swig_type_info _swigt__p_data1_node[] = {{"_p_data1_node", 0, "data1_node *", 0},{"_p_data1_node"},{0}};
static swig_type_info _swigt__p_ScanObj[] = {{"IDZebra::ScanObj", 0, "ScanObj *", 0},{"IDZebra::ScanObj"},{0}};
static swig_type_info _swigt__p_RetrievalObj[] = {{"IDZebra::RetrievalObj", 0, "RetrievalObj *", 0},{"IDZebra::RetrievalObj"},{0}};
static swig_type_info _swigt__p_data1_tagset[] = {{"_p_data1_tagset", 0, "data1_tagset *", 0},{"_p_data1_tagset"},{0}};
static swig_type_info _swigt__p_data1_tag[] = {{"_p_data1_tag", 0, "data1_tag *", 0},{"_p_data1_tag"},{0}};
static swig_type_info _swigt__p_ZebraRetrievalRecord[] = {{"_p_ZebraRetrievalRecord", 0, "ZebraRetrievalRecord *", 0},{"_p_ZebraRetrievalRecord"},{0}};
static swig_type_info _swigt__p_RetrievalRecord[] = {{"IDZebra::RetrievalRecord", 0, "RetrievalRecord *", 0},{"IDZebra::RetrievalRecord"},{0}};
static swig_type_info _swigt__p_NMEM[] = {{"_p_NMEM", 0, "NMEM *", 0},{"_p_NMEM"},{0}};
static swig_type_info _swigt__p_Z_ExplainRecord[] = {{"_p_Z_ExplainRecord", 0, "Z_ExplainRecord *", 0},{"_p_Z_ExplainRecord"},{0}};
static swig_type_info _swigt__p_data1_marctab[] = {{"_p_data1_marctab", 0, "data1_marctab *", 0},{"_p_data1_marctab"},{0}};
static swig_type_info _swigt__p_ZebraTransactionStatus[] = {{"IDZebra::ZebraTransactionStatus", 0, "ZebraTransactionStatus *", 0},{"IDZebra::ZebraTransactionStatus"},{0}};
static swig_type_info _swigt__p_Z_BriefBib[] = {{"_p_Z_BriefBib", 0, "Z_BriefBib *", 0},{"_p_Z_BriefBib"},{0}};
static swig_type_info _swigt__p_scanEntry[] = {{"IDZebra::scanEntry", 0, "scanEntry *", 0},{"IDZebra::scanEntry"},{0}};
static swig_type_info _swigt__p_f_p_void_p_char_size_t__int[] = {{"_p_f_p_void_p_char_size_t__int", 0, "int (*)(void *,char *,size_t)", 0},{"_p_f_p_void_p_char_size_t__int"},{0}};
static swig_type_info _swigt__p_FILE[] = {{"_p_FILE", 0, "FILE *", 0},{"_p_FILE"},{0}};
static swig_type_info _swigt__p_data1_element[] = {{"_p_data1_element", 0, "data1_element *", 0},{"_p_data1_element"},{0}};
static swig_type_info _swigt__p_recordGroup[] = {{"IDZebra::recordGroup", 0, "recordGroup *", 0},{"IDZebra::recordGroup"},{0}};
static swig_type_info _swigt__p_int[] = {{"_p_int", 0, "int *", 0},{"_p_int"},{0}};
static swig_type_info _swigt__p_data1_handle[] = {{"_p_data1_handle", 0, "data1_handle *", 0},{"_p_data1_handle"},{0}};
static swig_type_info _swigt__p_p_int[] = {{"_p_p_int", 0, "int **", 0},{"_p_p_int"},{0}};
static swig_type_info _swigt__p_data1_absyn_cache[] = {{"_p_data1_absyn_cache", 0, "data1_absyn_cache *", 0},{"_p_data1_absyn_cache"},{0}};
static swig_type_info _swigt__p_data1_attset_cache[] = {{"_p_data1_attset_cache", 0, "data1_attset_cache *", 0},{"_p_data1_attset_cache"},{0}};
static swig_type_info _swigt__p_Z_GenericRecord[] = {{"_p_Z_GenericRecord", 0, "Z_GenericRecord *", 0},{"_p_Z_GenericRecord"},{0}};
static swig_type_info _swigt__p_data1_vartype[] = {{"_p_data1_vartype", 0, "data1_vartype *", 0},{"_p_data1_vartype"},{0}};

static swig_type_info *swig_types_initial[] = {
_swigt__p_ZebraService, 
_swigt__p_cql_transform_t, 
_swigt__p_data1_esetname, 
_swigt__p_data1_maptab, 
_swigt__p_ODR, 
_swigt__p_f_p_void__int, 
_swigt__p_p_char, 
_swigt__p_data1_absyn, 
_swigt__p_ZebraHandle, 
_swigt__p_void, 
_swigt__p_data1_attset, 
_swigt__p_size_t, 
_swigt__p_WRBUF, 
_swigt__p_f_data1_handle_p_void_p_data1_absyn__void, 
_swigt__p_Z_Espec1, 
_swigt__p_off_t, 
_swigt__p_Odr_oid, 
_swigt__p_data1_varset, 
_swigt__p_RetrievalRecordBuf, 
_swigt__p_perl_context, 
_swigt__p_data1_node, 
_swigt__p_ScanObj, 
_swigt__p_RetrievalObj, 
_swigt__p_data1_tagset, 
_swigt__p_data1_tag, 
_swigt__p_ZebraRetrievalRecord, 
_swigt__p_RetrievalRecord, 
_swigt__p_NMEM, 
_swigt__p_Z_ExplainRecord, 
_swigt__p_data1_marctab, 
_swigt__p_ZebraTransactionStatus, 
_swigt__p_Z_BriefBib, 
_swigt__p_scanEntry, 
_swigt__p_f_p_void_p_char_size_t__int, 
_swigt__p_FILE, 
_swigt__p_data1_element, 
_swigt__p_recordGroup, 
_swigt__p_int, 
_swigt__p_data1_handle, 
_swigt__p_p_int, 
_swigt__p_data1_absyn_cache, 
_swigt__p_data1_attset_cache, 
_swigt__p_Z_GenericRecord, 
_swigt__p_data1_vartype, 
0
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

static swig_constant_info swig_constants[] = {
{ SWIG_INT,     (char *) SWIG_prefix "LOG_FATAL", (long) 0x0001, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LOG_DEBUG", (long) 0x0002, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LOG_WARN", (long) 0x0004, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LOG_LOG", (long) 0x0008, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LOG_ERRNO", (long) 0x0010, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LOG_FILE", (long) 0x0020, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LOG_APP", (long) 0x0040, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LOG_MALLOC", (long) 0x0080, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LOG_ALL", (long) 0xff7f, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "LOG_DEFAULT_LEVEL", (long) (0x0001|0x0010|0x0008|0x0004), 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "ODR_DECODE", (long) 0, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "ODR_ENCODE", (long) 1, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "ODR_PRINT", (long) 2, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DATA1K_unknown", (long) DATA1K_unknown, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DATA1K_structured", (long) DATA1K_structured, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DATA1K_string", (long) DATA1K_string, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DATA1K_numeric", (long) DATA1K_numeric, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DATA1K_bool", (long) DATA1K_bool, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DATA1K_oid", (long) DATA1K_oid, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DATA1K_generalizedtime", (long) DATA1K_generalizedtime, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DATA1K_intunit", (long) DATA1K_intunit, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DATA1K_int", (long) DATA1K_int, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DATA1K_octetstring", (long) DATA1K_octetstring, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DATA1K_null", (long) DATA1K_null, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DATA1T_numeric", (long) 1, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DATA1T_string", (long) 2, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DATA1N_root", (long) 1, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DATA1N_tag", (long) 2, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DATA1N_data", (long) 3, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DATA1N_variant", (long) 4, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DATA1N_comment", (long) 5, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DATA1N_preprocess", (long) 6, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DATA1I_inctxt", (long) 1, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DATA1I_incbin", (long) 2, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DATA1I_text", (long) 3, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DATA1I_num", (long) 4, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DATA1I_oid", (long) 5, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DATA1_LOCALDATA", (long) 12, 0, 0, 0},
{ SWIG_INT,     (char *) SWIG_prefix "DATA1_FLAG_XML", (long) 1, 0, 0, 0},
{0}
};
#ifdef __cplusplus
}
#endif
static swig_variable_info swig_variables[] = {
{0}
};
static swig_command_info swig_commands[] = {
{"IDZebrac::recordGroup_groupName_set", _wrap_recordGroup_groupName_set},
{"IDZebrac::recordGroup_groupName_get", _wrap_recordGroup_groupName_get},
{"IDZebrac::recordGroup_databaseName_set", _wrap_recordGroup_databaseName_set},
{"IDZebrac::recordGroup_databaseName_get", _wrap_recordGroup_databaseName_get},
{"IDZebrac::recordGroup_path_set", _wrap_recordGroup_path_set},
{"IDZebrac::recordGroup_path_get", _wrap_recordGroup_path_get},
{"IDZebrac::recordGroup_recordId_set", _wrap_recordGroup_recordId_set},
{"IDZebrac::recordGroup_recordId_get", _wrap_recordGroup_recordId_get},
{"IDZebrac::recordGroup_recordType_set", _wrap_recordGroup_recordType_set},
{"IDZebrac::recordGroup_recordType_get", _wrap_recordGroup_recordType_get},
{"IDZebrac::recordGroup_flagStoreData_set", _wrap_recordGroup_flagStoreData_set},
{"IDZebrac::recordGroup_flagStoreData_get", _wrap_recordGroup_flagStoreData_get},
{"IDZebrac::recordGroup_flagStoreKeys_set", _wrap_recordGroup_flagStoreKeys_set},
{"IDZebrac::recordGroup_flagStoreKeys_get", _wrap_recordGroup_flagStoreKeys_get},
{"IDZebrac::recordGroup_flagRw_set", _wrap_recordGroup_flagRw_set},
{"IDZebrac::recordGroup_flagRw_get", _wrap_recordGroup_flagRw_get},
{"IDZebrac::recordGroup_fileVerboseLimit_set", _wrap_recordGroup_fileVerboseLimit_set},
{"IDZebrac::recordGroup_fileVerboseLimit_get", _wrap_recordGroup_fileVerboseLimit_get},
{"IDZebrac::recordGroup_databaseNamePath_set", _wrap_recordGroup_databaseNamePath_set},
{"IDZebrac::recordGroup_databaseNamePath_get", _wrap_recordGroup_databaseNamePath_get},
{"IDZebrac::recordGroup_explainDatabase_set", _wrap_recordGroup_explainDatabase_set},
{"IDZebrac::recordGroup_explainDatabase_get", _wrap_recordGroup_explainDatabase_get},
{"IDZebrac::recordGroup_followLinks_set", _wrap_recordGroup_followLinks_set},
{"IDZebrac::recordGroup_followLinks_get", _wrap_recordGroup_followLinks_get},
{"IDZebrac::new_recordGroup", _wrap_new_recordGroup},
{"IDZebrac::delete_recordGroup", _wrap_delete_recordGroup},
{"IDZebrac::RetrievalObj_noOfRecords_set", _wrap_RetrievalObj_noOfRecords_set},
{"IDZebrac::RetrievalObj_noOfRecords_get", _wrap_RetrievalObj_noOfRecords_get},
{"IDZebrac::RetrievalObj_records_set", _wrap_RetrievalObj_records_set},
{"IDZebrac::RetrievalObj_records_get", _wrap_RetrievalObj_records_get},
{"IDZebrac::new_RetrievalObj", _wrap_new_RetrievalObj},
{"IDZebrac::delete_RetrievalObj", _wrap_delete_RetrievalObj},
{"IDZebrac::RetrievalRecord_errCode_set", _wrap_RetrievalRecord_errCode_set},
{"IDZebrac::RetrievalRecord_errCode_get", _wrap_RetrievalRecord_errCode_get},
{"IDZebrac::RetrievalRecord_errString_set", _wrap_RetrievalRecord_errString_set},
{"IDZebrac::RetrievalRecord_errString_get", _wrap_RetrievalRecord_errString_get},
{"IDZebrac::RetrievalRecord_position_set", _wrap_RetrievalRecord_position_set},
{"IDZebrac::RetrievalRecord_position_get", _wrap_RetrievalRecord_position_get},
{"IDZebrac::RetrievalRecord_base_set", _wrap_RetrievalRecord_base_set},
{"IDZebrac::RetrievalRecord_base_get", _wrap_RetrievalRecord_base_get},
{"IDZebrac::RetrievalRecord_sysno_set", _wrap_RetrievalRecord_sysno_set},
{"IDZebrac::RetrievalRecord_sysno_get", _wrap_RetrievalRecord_sysno_get},
{"IDZebrac::RetrievalRecord_score_set", _wrap_RetrievalRecord_score_set},
{"IDZebrac::RetrievalRecord_score_get", _wrap_RetrievalRecord_score_get},
{"IDZebrac::RetrievalRecord_format_set", _wrap_RetrievalRecord_format_set},
{"IDZebrac::RetrievalRecord_format_get", _wrap_RetrievalRecord_format_get},
{"IDZebrac::RetrievalRecord_buf_set", _wrap_RetrievalRecord_buf_set},
{"IDZebrac::RetrievalRecord_buf_get", _wrap_RetrievalRecord_buf_get},
{"IDZebrac::new_RetrievalRecord", _wrap_new_RetrievalRecord},
{"IDZebrac::delete_RetrievalRecord", _wrap_delete_RetrievalRecord},
{"IDZebrac::scanEntry_occurrences_set", _wrap_scanEntry_occurrences_set},
{"IDZebrac::scanEntry_occurrences_get", _wrap_scanEntry_occurrences_get},
{"IDZebrac::scanEntry_term_set", _wrap_scanEntry_term_set},
{"IDZebrac::scanEntry_term_get", _wrap_scanEntry_term_get},
{"IDZebrac::new_scanEntry", _wrap_new_scanEntry},
{"IDZebrac::delete_scanEntry", _wrap_delete_scanEntry},
{"IDZebrac::ScanObj_num_entries_set", _wrap_ScanObj_num_entries_set},
{"IDZebrac::ScanObj_num_entries_get", _wrap_ScanObj_num_entries_get},
{"IDZebrac::ScanObj_position_set", _wrap_ScanObj_position_set},
{"IDZebrac::ScanObj_position_get", _wrap_ScanObj_position_get},
{"IDZebrac::ScanObj_is_partial_set", _wrap_ScanObj_is_partial_set},
{"IDZebrac::ScanObj_is_partial_get", _wrap_ScanObj_is_partial_get},
{"IDZebrac::ScanObj_entries_set", _wrap_ScanObj_entries_set},
{"IDZebrac::ScanObj_entries_get", _wrap_ScanObj_entries_get},
{"IDZebrac::new_ScanObj", _wrap_new_ScanObj},
{"IDZebrac::delete_ScanObj", _wrap_delete_ScanObj},
{"IDZebrac::ZebraTransactionStatus_processed_set", _wrap_ZebraTransactionStatus_processed_set},
{"IDZebrac::ZebraTransactionStatus_processed_get", _wrap_ZebraTransactionStatus_processed_get},
{"IDZebrac::ZebraTransactionStatus_inserted_set", _wrap_ZebraTransactionStatus_inserted_set},
{"IDZebrac::ZebraTransactionStatus_inserted_get", _wrap_ZebraTransactionStatus_inserted_get},
{"IDZebrac::ZebraTransactionStatus_updated_set", _wrap_ZebraTransactionStatus_updated_set},
{"IDZebrac::ZebraTransactionStatus_updated_get", _wrap_ZebraTransactionStatus_updated_get},
{"IDZebrac::ZebraTransactionStatus_deleted_set", _wrap_ZebraTransactionStatus_deleted_set},
{"IDZebrac::ZebraTransactionStatus_deleted_get", _wrap_ZebraTransactionStatus_deleted_get},
{"IDZebrac::ZebraTransactionStatus_utime_set", _wrap_ZebraTransactionStatus_utime_set},
{"IDZebrac::ZebraTransactionStatus_utime_get", _wrap_ZebraTransactionStatus_utime_get},
{"IDZebrac::ZebraTransactionStatus_stime_set", _wrap_ZebraTransactionStatus_stime_set},
{"IDZebrac::ZebraTransactionStatus_stime_get", _wrap_ZebraTransactionStatus_stime_get},
{"IDZebrac::new_ZebraTransactionStatus", _wrap_new_ZebraTransactionStatus},
{"IDZebrac::delete_ZebraTransactionStatus", _wrap_delete_ZebraTransactionStatus},
{"IDZebrac::DESTROY", _wrap_DESTROY},
{"IDZebrac::logLevel", _wrap_logLevel},
{"IDZebrac::logFile", _wrap_logFile},
{"IDZebrac::logMsg", _wrap_logMsg},
{"IDZebrac::logPrefix", _wrap_logPrefix},
{"IDZebrac::logPrefix2", _wrap_logPrefix2},
{"IDZebrac::odr_createmem", _wrap_odr_createmem},
{"IDZebrac::odr_reset", _wrap_odr_reset},
{"IDZebrac::odr_destroy", _wrap_odr_destroy},
{"IDZebrac::odr_malloc", _wrap_odr_malloc},
{"IDZebrac::start", _wrap_start},
{"IDZebrac::open", _wrap_open},
{"IDZebrac::close", _wrap_close},
{"IDZebrac::stop", _wrap_stop},
{"IDZebrac::errCode", _wrap_errCode},
{"IDZebrac::errString", _wrap_errString},
{"IDZebrac::errAdd", _wrap_errAdd},
{"IDZebrac::init_recordGroup", _wrap_init_recordGroup},
{"IDZebrac::res_get_recordGroup", _wrap_res_get_recordGroup},
{"IDZebrac::set_group", _wrap_set_group},
{"IDZebrac::select_database", _wrap_select_database},
{"IDZebrac::select_databases", _wrap_select_databases},
{"IDZebrac::begin_trans", _wrap_begin_trans},
{"IDZebrac::end_trans", _wrap_end_trans},
{"IDZebrac::trans_no", _wrap_trans_no},
{"IDZebrac::commit", _wrap_commit},
{"IDZebrac::get_shadow_enable", _wrap_get_shadow_enable},
{"IDZebrac::set_shadow_enable", _wrap_set_shadow_enable},
{"IDZebrac::init", _wrap_init},
{"IDZebrac::compact", _wrap_compact},
{"IDZebrac::repository_update", _wrap_repository_update},
{"IDZebrac::repository_delete", _wrap_repository_delete},
{"IDZebrac::repository_show", _wrap_repository_show},
{"IDZebrac::insert_record", _wrap_insert_record},
{"IDZebrac::update_record", _wrap_update_record},
{"IDZebrac::delete_record", _wrap_delete_record},
{"IDZebrac::search_PQF", _wrap_search_PQF},
{"IDZebrac::cql_transform_open_fname", _wrap_cql_transform_open_fname},
{"IDZebrac::cql_transform_close", _wrap_cql_transform_close},
{"IDZebrac::cql_transform_error", _wrap_cql_transform_error},
{"IDZebrac::cql2pqf", _wrap_cql2pqf},
{"IDZebrac::records_retrieve", _wrap_records_retrieve},
{"IDZebrac::record_retrieve", _wrap_record_retrieve},
{"IDZebrac::deleteResultSet", _wrap_deleteResultSet},
{"IDZebrac::resultSetTerms", _wrap_resultSetTerms},
{"IDZebrac::sort", _wrap_sort},
{"IDZebrac::scan_PQF", _wrap_scan_PQF},
{"IDZebrac::getScanEntry", _wrap_getScanEntry},
{"IDZebrac::nmem_create", _wrap_nmem_create},
{"IDZebrac::nmem_destroy", _wrap_nmem_destroy},
{"IDZebrac::data1_create", _wrap_data1_create},
{"IDZebrac::data1_createx", _wrap_data1_createx},
{"IDZebrac::data1_destroy", _wrap_data1_destroy},
{"IDZebrac::get_parent_tag", _wrap_get_parent_tag},
{"IDZebrac::data1_read_node", _wrap_data1_read_node},
{"IDZebrac::data1_read_nodex", _wrap_data1_read_nodex},
{"IDZebrac::data1_read_record", _wrap_data1_read_record},
{"IDZebrac::data1_read_absyn", _wrap_data1_read_absyn},
{"IDZebrac::data1_gettagbynum", _wrap_data1_gettagbynum},
{"IDZebrac::data1_empty_tagset", _wrap_data1_empty_tagset},
{"IDZebrac::data1_read_tagset", _wrap_data1_read_tagset},
{"IDZebrac::data1_getelementbytagname", _wrap_data1_getelementbytagname},
{"IDZebrac::data1_nodetogr", _wrap_data1_nodetogr},
{"IDZebrac::data1_gettagbyname", _wrap_data1_gettagbyname},
{"IDZebrac::data1_free_tree", _wrap_data1_free_tree},
{"IDZebrac::data1_nodetobuf", _wrap_data1_nodetobuf},
{"IDZebrac::data1_mk_tag_data_wd", _wrap_data1_mk_tag_data_wd},
{"IDZebrac::data1_mk_tag_data", _wrap_data1_mk_tag_data},
{"IDZebrac::data1_maptype", _wrap_data1_maptype},
{"IDZebrac::data1_read_varset", _wrap_data1_read_varset},
{"IDZebrac::data1_getvartypebyct", _wrap_data1_getvartypebyct},
{"IDZebrac::data1_read_espec1", _wrap_data1_read_espec1},
{"IDZebrac::data1_doespec1", _wrap_data1_doespec1},
{"IDZebrac::data1_getesetbyname", _wrap_data1_getesetbyname},
{"IDZebrac::data1_getelementbyname", _wrap_data1_getelementbyname},
{"IDZebrac::data1_mk_node2", _wrap_data1_mk_node2},
{"IDZebrac::data1_mk_tag", _wrap_data1_mk_tag},
{"IDZebrac::data1_mk_tag_n", _wrap_data1_mk_tag_n},
{"IDZebrac::data1_tag_add_attr", _wrap_data1_tag_add_attr},
{"IDZebrac::data1_mk_text_n", _wrap_data1_mk_text_n},
{"IDZebrac::data1_mk_text_nf", _wrap_data1_mk_text_nf},
{"IDZebrac::data1_mk_text", _wrap_data1_mk_text},
{"IDZebrac::data1_mk_comment_n", _wrap_data1_mk_comment_n},
{"IDZebrac::data1_mk_comment", _wrap_data1_mk_comment},
{"IDZebrac::data1_mk_preprocess", _wrap_data1_mk_preprocess},
{"IDZebrac::data1_mk_root", _wrap_data1_mk_root},
{"IDZebrac::data1_set_root", _wrap_data1_set_root},
{"IDZebrac::data1_mk_tag_data_int", _wrap_data1_mk_tag_data_int},
{"IDZebrac::data1_mk_tag_data_oid", _wrap_data1_mk_tag_data_oid},
{"IDZebrac::data1_mk_tag_data_text", _wrap_data1_mk_tag_data_text},
{"IDZebrac::data1_mk_tag_data_text_uni", _wrap_data1_mk_tag_data_text_uni},
{"IDZebrac::data1_get_absyn", _wrap_data1_get_absyn},
{"IDZebrac::data1_search_tag", _wrap_data1_search_tag},
{"IDZebrac::data1_mk_tag_uni", _wrap_data1_mk_tag_uni},
{"IDZebrac::data1_get_attset", _wrap_data1_get_attset},
{"IDZebrac::data1_read_maptab", _wrap_data1_read_maptab},
{"IDZebrac::data1_map_record", _wrap_data1_map_record},
{"IDZebrac::data1_read_marctab", _wrap_data1_read_marctab},
{"IDZebrac::data1_nodetomarc", _wrap_data1_nodetomarc},
{"IDZebrac::data1_nodetoidsgml", _wrap_data1_nodetoidsgml},
{"IDZebrac::data1_nodetoexplain", _wrap_data1_nodetoexplain},
{"IDZebrac::data1_nodetosummary", _wrap_data1_nodetosummary},
{"IDZebrac::data1_nodetosoif", _wrap_data1_nodetosoif},
{"IDZebrac::data1_get_wrbuf", _wrap_data1_get_wrbuf},
{"IDZebrac::data1_get_read_buf", _wrap_data1_get_read_buf},
{"IDZebrac::data1_get_map_buf", _wrap_data1_get_map_buf},
{"IDZebrac::data1_absyn_cache_get", _wrap_data1_absyn_cache_get},
{"IDZebrac::data1_attset_cache_get", _wrap_data1_attset_cache_get},
{"IDZebrac::data1_nmem_get", _wrap_data1_nmem_get},
{"IDZebrac::data1_pr_tree", _wrap_data1_pr_tree},
{"IDZebrac::data1_print_tree", _wrap_data1_print_tree},
{"IDZebrac::data1_insert_string", _wrap_data1_insert_string},
{"IDZebrac::data1_insert_string_n", _wrap_data1_insert_string_n},
{"IDZebrac::data1_read_sgml", _wrap_data1_read_sgml},
{"IDZebrac::data1_absyn_trav", _wrap_data1_absyn_trav},
{"IDZebrac::data1_attset_search_id", _wrap_data1_attset_search_id},
{"IDZebrac::data1_getNodeValue", _wrap_data1_getNodeValue},
{"IDZebrac::data1_LookupNode", _wrap_data1_LookupNode},
{"IDZebrac::data1_CountOccurences", _wrap_data1_CountOccurences},
{"IDZebrac::data1_path_fopen", _wrap_data1_path_fopen},
{"IDZebrac::data1_set_tabpath", _wrap_data1_set_tabpath},
{"IDZebrac::data1_set_tabroot", _wrap_data1_set_tabroot},
{"IDZebrac::data1_get_tabpath", _wrap_data1_get_tabpath},
{"IDZebrac::data1_get_tabroot", _wrap_data1_get_tabroot},
{"IDZebrac::grs_perl_readf", _wrap_grs_perl_readf},
{"IDZebrac::grs_perl_readline", _wrap_grs_perl_readline},
{"IDZebrac::grs_perl_getc", _wrap_grs_perl_getc},
{"IDZebrac::grs_perl_seekf", _wrap_grs_perl_seekf},
{"IDZebrac::grs_perl_tellf", _wrap_grs_perl_tellf},
{"IDZebrac::grs_perl_endf", _wrap_grs_perl_endf},
{"IDZebrac::grs_perl_get_dh", _wrap_grs_perl_get_dh},
{"IDZebrac::grs_perl_get_mem", _wrap_grs_perl_get_mem},
{"IDZebrac::grs_perl_set_res", _wrap_grs_perl_set_res},
{0,0}
};

#ifdef __cplusplus
extern "C"
#endif

XS(SWIG_init) {
    dXSARGS;
    int i;
    static int _init = 0;
    if (!_init) {
        for (i = 0; swig_types_initial[i]; i++) {
            swig_types[i] = SWIG_TypeRegister(swig_types_initial[i]);
        }
        _init = 1;
    }
    
    /* Install commands */
    for (i = 0; swig_commands[i].name; i++) {
        newXS((char*) swig_commands[i].name,swig_commands[i].wrapper, (char*)__FILE__);
    }
    
    /* Install variables */
    for (i = 0; swig_variables[i].name; i++) {
        SV *sv;
        sv = perl_get_sv((char*) swig_variables[i].name, TRUE | 0x2);
        if (swig_variables[i].type) {
            SWIG_MakePtr(sv,(void *)1, *swig_variables[i].type,0);
        }else {
            sv_setiv(sv,(IV) 0);
        }
        swig_create_magic(sv, (char *) swig_variables[i].name, swig_variables[i].set, swig_variables[i].get); 
    }
    
    /* Install constant */
    for (i = 0; swig_constants[i].type; i++) {
        SV *sv;
        sv = perl_get_sv((char*)swig_constants[i].name, TRUE | 0x2);
        switch(swig_constants[i].type) {
            case SWIG_INT:
            sv_setiv(sv, (IV) swig_constants[i].lvalue);
            break;
            case SWIG_FLOAT:
            sv_setnv(sv, (double) swig_constants[i].dvalue);
            break;
            case SWIG_STRING:
            sv_setpv(sv, (char *) swig_constants[i].pvalue);
            break;
            case SWIG_POINTER:
            SWIG_MakePtr(sv, swig_constants[i].pvalue, *(swig_constants[i].ptype),0);
            break;
            case SWIG_BINARY:
            /*      obj = SWIG_NewPackedObj(swig_constants[i].pvalue, swig_constants[i].lvalue, *(swig_constants[i].ptype)); */
            break;
            default:
            break;
        }
        SvREADONLY_on(sv);
    }
    
    SWIG_TypeClientData(SWIGTYPE_p_recordGroup, (void*) "IDZebra::recordGroup");
    SWIG_TypeClientData(SWIGTYPE_p_RetrievalObj, (void*) "IDZebra::RetrievalObj");
    SWIG_TypeClientData(SWIGTYPE_p_RetrievalRecord, (void*) "IDZebra::RetrievalRecord");
    SWIG_TypeClientData(SWIGTYPE_p_scanEntry, (void*) "IDZebra::scanEntry");
    SWIG_TypeClientData(SWIGTYPE_p_ScanObj, (void*) "IDZebra::ScanObj");
    SWIG_TypeClientData(SWIGTYPE_p_ZebraTransactionStatus, (void*) "IDZebra::ZebraTransactionStatus");
    ST(0) = &PL_sv_yes;
    XSRETURN(1);
}

