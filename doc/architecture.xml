 <chapter id="architecture">
  <!-- $Id: architecture.xml,v 1.5 2006-02-16 16:50:18 marc Exp $ -->
  <title>Overview of Zebra Architecture</title>
  

  <sect1 id="architecture-representation">
   <title>Local Representation</title>

   <para>
    As mentioned earlier, Zebra places few restrictions on the type of
    data that you can index and manage. Generally, whatever the form of
    the data, it is parsed by an input filter specific to that format, and
    turned into an internal structure that Zebra knows how to handle. This
    process takes place whenever the record is accessed - for indexing and
    retrieval.
   </para>

   <para>
    The RecordType parameter in the <literal>zebra.cfg</literal> file, or
    the <literal>-t</literal> option to the indexer tells Zebra how to
    process input records.
    Two basic types of processing are available - raw text and structured
    data. Raw text is just that, and it is selected by providing the
    argument <emphasis>text</emphasis> to Zebra. Structured records are
    all handled internally using the basic mechanisms described in the
    subsequent sections.
    Zebra can read structured records in many different formats.
    <!--
    How this is done is governed by additional parameters after the
    "grs" keyword, separated by "." characters.
    -->
   </para>
  </sect1>

  <sect1 id="architecture-maincomponents">
   <title>Main Components</title>
   <para>
    The Zebra system is designed to support a wide range of data management
    applications. The system can be configured to handle virtually any
    kind of structured data. Each record in the system is associated with
    a <emphasis>record schema</emphasis> which lends context to the data
    elements of the record.
    Any number of record schemas can coexist in the system.
    Although it may be wise to use only a single schema within
    one database, the system poses no such restrictions.
   </para>
   <para>
    The Zebra indexer and information retrieval server consists of the
    following main applications: the <literal>zebraidx</literal>
    indexing maintenance utility, and the <literal>zebrasrv</literal>
    information query and retireval server. Both are using some of the
    same main components, which are presented here.
   </para>    
   <para>    
    This virtual package installs all the necessary packages to start
    working with Zebra - including utility programs, development libraries,
    documentation and modules.
     <literal>idzebra1.4</literal>
  </para>    
   
   <sect2 id="componentcore">
    <title>Core Zebra Module Containing Common Functionality</title>
    <para>
     - loads external filter modules used for presenting
     the recods in a search response.
     - executes search requests in PQF/RPN, which are handed over from
     the YAZ server frontend API   
     - calls resorting/reranking algorithms on the hit sets
     - returns - possibly ranked - result sets, hit
     numbers, and the like internal data to the YAZ server backend API.
    </para>
    <para> 
     This package contains all run-time libraries for Zebra.
     <literal>libidzebra1.4</literal> 
     This package includes documentation for Zebra in PDF and HTML.
     <literal>idzebra1.4-doc</literal> 
     This package includes common essential Zebra configuration files
     <literal>idzebra1.4-common</literal>
    </para>
   </sect2>
   

   <sect2 id="componentindexer">
    <title>Zebra Indexer</title>
    <para>
     the core Zebra indexer which
     - loads external filter modules used for indexing data records of
     different type. 
     - creates, updates and drops databases and indexes
    </para>    
    <para>    
     This package contains Zebra utilities such as the zebraidx indexer
     utility and the zebrasrv server.
     <literal>idzebra1.4-utils</literal>
    </para>
   </sect2>

   <sect2 id="componentsearcher">
    <title>Zebra Searcher/Retriever</title>
    <para>
     the core Zebra searcher/retriever which
    </para>    
    <para>    
     This package contains Zebra utilities such as the zebraidx indexer
     utility and the zebrasrv server, and their associated man pages.
     <literal>idzebra1.4-utils</literal>
    </para>
   </sect2>

   <sect2 id="componentyazserver">
    <title>YAZ Server Frontend</title>
    <para>
     The YAZ server frontend is 
     a full fledged stateful Z39.50 server taking client
     connections, and forwarding search and scan requests to the 
     Zebra core indexer.
    </para>
    <para>
     In addition to Z39.50 requests, the YAZ server frontend acts
     as HTTP server, honouring
      <ulink url="http://www.loc.gov/standards/sru/srw/">SRW</ulink> SOAP requests, and  <ulink url="http://www.loc.gov/standards/sru/">SRU</ulink> REST requests. Moreover, it can
     translate inco ming <ulink url="http://www.loc.gov/standards/sru/cql/">CQL</ulink> queries to PQF/RPN queries, if
     correctly configured. 
    </para>
    <para>
    YAZ is a toolkit that allows you to develop software using the
    ANSI Z39.50/ISO23950 standard for information retrieval.
     <ulink url="http://www.loc.gov/standards/sru/srw/">SRW</ulink>/ <ulink url="http://www.loc.gov/standards/sru/">SRU</ulink>
    <literal>libyazthread.so</literal>
    <literal>libyaz.so</literal>
    <literal>libyaz</literal>
    </para>
   </sect2>
   
   <sect2 id="componentmodules">
    <title>Record Models and Filter Modules</title>
    <para>
      all filter modules which do indexing and record display filtering:
This virtual package contains all base IDZebra filter modules. EMPTY ???
     <literal>libidzebra1.4-modules</literal>
    </para>

   <sect3 id="componentmodulestext">
    <title>TEXT Record Model and Filter Module</title>
    <para>
      Plain ASCII text filter
     <!--
     <literal>text module missing as deb file<literal>
     -->
    </para>
   </sect3>

   <sect3 id="componentmodulesgrs">
    <title>GRS Record Model and Filter Modules</title>
    <para>
    <xref linkend="record-model-grs"/>

     - grs.danbib     GRS filters of various kind (*.abs files)
IDZebra filter grs.danbib (DBC DanBib records)
  This package includes grs.danbib filter which parses DanBib records.
  DanBib is the Danish Union Catalogue hosted by DBC
  (Danish Bibliographic Centre).
     <literal>libidzebra1.4-mod-grs-danbib</literal>


     - grs.marc
     - grs.marcxml
  This package includes the grs.marc and grs.marcxml filters that allows
  IDZebra to read MARC records based on ISO2709.

     <literal>libidzebra1.4-mod-grs-marc</literal>

     - grs.regx
     - grs.tcl        GRS TCL scriptable filter
  This package includes the grs.regx and grs.tcl filters.
     <literal>libidzebra1.4-mod-grs-regx</literal>


     - grs.sgml
     <literal>libidzebra1.4-mod-grs-sgml not packaged yet ??</literal>

     - grs.xml
  This package includes the grs.xml filter which uses <ulink url="http://expat.sourceforge.net/">Expat</ulink> to
  parse records in XML and turn them into IDZebra's internal grs node.
     <literal>libidzebra1.4-mod-grs-xml</literal>
    </para>
   </sect3>

   <sect3 id="componentmodulesalvis">
    <title>ALVIS Record Model and Filter Module</title>
     <para>
      <xref linkend="record-model-alvisxslt"/>
      - alvis          Experimental Alvis XSLT filter
      <literal>mod-alvis.so</literal>
      <literal>libidzebra1.4-mod-alvis</literal>
     </para>
    </sect3>

   <sect3 id="componentmodulessafari">
    <title>SAFARI Record Model and Filter Module</title>
    <para>
     - safari
     <!--
     <literal>safari module missing as deb file<literal>
     -->
    </para>
   </sect3>

   </sect2>

  </sect1>


  <sect1 id="architecture-workflow">
   <title>Indexing and Retrieval Workflow</title>

  <para>
   Records pass through three different states during processing in the
   system.
  </para>

  <para>

   <itemizedlist>
    <listitem>
     
     <para>
      When records are accessed by the system, they are represented
      in their local, or native format. This might be SGML or HTML files,
      News or Mail archives, MARC records. If the system doesn't already
      know how to read the type of data you need to store, you can set up an
      input filter by preparing conversion rules based on regular
      expressions and possibly augmented by a flexible scripting language
      (Tcl).
      The input filter produces as output an internal representation,
      a tree structure.

     </para>
    </listitem>
    <listitem>

     <para>
      When records are processed by the system, they are represented
      in a tree-structure, constructed by tagged data elements hanging off a
      root node. The tagged elements may contain data or yet more tagged
      elements in a recursive structure. The system performs various
      actions on this tree structure (indexing, element selection, schema
      mapping, etc.),

     </para>
    </listitem>
    <listitem>

     <para>
      Before transmitting records to the client, they are first
      converted from the internal structure to a form suitable for exchange
      over the network - according to the Z39.50 standard.
     </para>
    </listitem>

   </itemizedlist>

  </para>
  </sect1>


 </chapter> 

 <!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
 sgml-parent-document: "zebra.xml"
 sgml-local-catalogs: nil
 sgml-namecase-general:t
 End:
 -->
